---
title: "Statistique_and_models"
format: pdf
editor: visual
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Etude exploratoire des données

```{r, warning= FALSE, message= FALSE}

# 2. Load the conflicted package first to manage masking
library(conflicted)

conflict_prefer("filter", "dplyr")
conflict_prefer("lag",    "dplyr")
conflict_prefer("select", "dplyr")
conflict_prefer("union",    "base")
conflict_prefer("intersect","base")
conflict_prefer("setdiff",  "base")
conflict_prefer("setequal", "base")
conflict_prefer("select", "dplyr")  # keep select
conflict_prefer("area",   "terra")
conflict_prefer("extract", "tidyr")
conflict_prefer("step", "recipes")
conflict_prefer("discard", "scales")
conflict_prefer("spec", "readr")

# 4. Load core libraries
library(dplyr)
library(tidyverse)
library(stargazer)
library(ggplot2)
library(rnaturalearth)
library(sf)
library(viridis)
library(corrplot)

# 5. Load spatial/ecological analysis packages
library(rnaturalearthdata)
library(raster)
library(terra)
library(spatstat)
library(spdep)

# 6. Load modeling and visualization packages
library(factoextra)
library(FactoMineR)
library(umap)
library(tmap)
library(dbscan)
library(mice)
library(leaps)
library(bestglm)
library(tidymodels)
library(caret)
library(patchwork)
library(RColorBrewer)

library(yardstick)
library(vip)
library(tidymodels)
```

```{r, warning= FALSE, message= FALSE}

df_fonds_EDMD= read.csv("/home/emiliano/Documents/MASTER_MAS/ALTERNANCE/FONDS VERT/DATA_PRETREATMENT/fonds_vert.csv", sep = ",", dec= ".")

# Création de variable binaire relative à la variable cible
df_fonds_EDMD$statut_finance_ecolo_dmd <- as.numeric(df_fonds_EDMD$cp_EDMD > 0)


```

# Pré-traitement et gestion des données manquantes

```{r}
# Transformation des colonnes a double modalité en facteur

df_fonds_EDMD <- df_fonds_EDMD %>%
  mutate(across(c(gridens7, gare_tgv, ecoquartiers, climat, beneficiaire_prog, statut_finance_ecolo_dmd), as.factor)) %>% 
  dplyr::select(where(~ n_distinct(.) > 1))
```

```{r, warning= FALSE, message= FALSE}
n = dim(df_fonds_EDMD)[1]
p = dim(df_fonds_EDMD)[2]

col_name= c()
total_na= c()

for (j in c(1:p)) {
  tot_na= sum(is.na(df_fonds_EDMD[, j]))
  if(tot_na > 0){
  col_name= c(col_name, colnames(df_fonds_EDMD)[j])
  total_na= c(total_na, tot_na)
  }
}

data.frame("columns_names"=
                   col_name,
           "Total_na" = total_na)
```

```{r, warning= FALSE, message= FALSE}
# Imputation multiple par chaînes de Markov (valeurs plausibles)
imputed_data <- mice(df_fonds_EDMD, method = "rf", m = 5)
df_fonds_EDMD <- complete(imputed_data)
```

# Statistiques descriptives

```{r, warning= FALSE, message= FALSE}
df_fonds_EDMD %>%
  dplyr::select(-c("code_com","code_dept","code_arr","lib_com","lib_arr","lib_dept")) %>% stargazer( ., type = "text", title="Descriptive statistics", digits=2)

```

```{r}
#summary(df_fonds_EDMD$cp_EDMD)

cible_var= df_fonds_EDMD$cp_EDMD

par(mfrow=c(1,2), las=1)

plot(sort(cible_var), col=rev(terrain.colors(length(cible_var))),ylim=c(0,2e+08), pch=20, cex=.75, ylab='cp_EDMD')

hist(cible_var, main='', col=rev(terrain.colors(5)),  xlim=c(0,4e+08), xlab='cp_EDMD')

```

```{r}
repr_boxplot_multiple= function(data, col_select, coord_cart, y_lib){
  
  # Passage au format long
  df <- data %>% 
    dplyr::select(col_select) %>%  
    pivot_longer(cols = everything(), names_to = "variable", values_to = "valeur")
  
  # Tracé des boxplots avec ggplot2
  ggplot(df, aes(x = variable, y = valeur, fill = variable)) +
    geom_boxplot() +
    theme_minimal() +
    labs( x = "Variable", y = "Valeur") +
    scale_fill_brewer(palette = "Set2") + 
    theme(axis.text.x = element_blank()) +
    geom_boxplot(outlier.shape = NA) +
    coord_cartesian(ylim = c(0, coord_cart)) + 
    ylab(y_lib)
  }

col <- colorRampPalette(c("#BB4444", "#EE9988", "beige", "orange", "#77AADD", "#4477AA"))
 


repr_matrice_cor= function(data,col_select){
  
  df= data %>% dplyr:: select(col_select)
  
  df_cor= cor(df)
  print(df_cor)
  corrplot::corrplot(df_cor, method="circle", col=col(200),  
                 type="upper", order="hclust", # Ajout du coefficient de corrélation
                 tl.col="black", tl.srt=45, #Rotation des etiquettes de textes
                 addCoef.col = "black",     
                 number.cex = 0.7,
                 p.mat = df_cor, sig.level = 1, insig = "blank", 
                 diag=FALSE )
  
  
    }

repr_boxplot= function(data, var_fact, compare_var, clr, coord_y_val){
  ggplot(data, aes(x=data[,var_fact], y=data[,compare_var], fill=data[,var_fact])) +
      geom_boxplot(outlier.color = "red") +scale_fill_viridis(discrete = TRUE, alpha=0.6) +
        scale_fill_manual(values = clr)  +
      theme( legend.position="none",plot.title = element_text(size=10))+
      ylab(compare_var)+
      xlab(var_fact)+
    coord_cartesian(ylim = c(0, coord_y_val))
  }

```

```{r}
repr_boxplot_multiple(data= df_fonds_EDMD, 
                      col_select= c("etab_AAS", "etab_AFA", "etab_AI", "etab_APESAS", 
                                    "etab_ASTSA", "etab_construction", "etab_CTHR", 
                                    "etab_IC", "etab_industrie"), 
                      coord_cart= 50,
                      y_lib= "Nombre d'établissement")

```

```{r}
repr_matrice_cor(data= df_fonds_EDMD, col_select = c("cp_EDMD", "etab_AAS", "etab_AFA", "etab_AI", 
                                                     "etab_APESAS","etab_ASTSA", "etab_construction",
                                                     "etab_CTHR", "etab_IC","etab_industrie")
                 )
```

```{r}

repr_boxplot(data= df_fonds_EDMD, var_fact= "ecoquartiers", compare_var= "cp_EDMD", clr= c("#FF9999", "#66B2FF"), coord_y_val= 2e+08)
```

```{r}

repr_boxplot(data= df_fonds_EDMD, var_fact= "ecoquartiers", compare_var= "CSP_maire", clr= c("#FF9999", "violet"), coord_y_val= 100)

```

```{r, echo= F}
#
repr_matrice_cor(data= df_fonds_EDMD, col_select = c("cp_EDMD", "med_disp", "com_variation_encours_dette_ha_pct", "dependance_eco"))
```

```{r}
repr_matrice_cor(data= df_fonds_EDMD, col_select = c("cp_EDMD", "eolienne_PE_kw",  
                                                     "hydroelectrique_PE_kw", "photovoltaique_PE_kw", 
                                                     "fossile_PE_kw", "incinerateur_PE_kw", 
                                                     "chaufferie_bois_PE_kw", "methaniseur_PE_kw"))

repr_matrice_cor(data= df_fonds_EDMD, col_select = c("cp_EDMD", "emissions_ges", "fossile_PT_kw", "incinerateur_PT_kw", "chaufferie_bois_PT_kw", "methaniseur_PT_kw"))
```

```{r}

# Création d'un dataframe résumant les totaux par type d'installation
df_pie_installation <- df_fonds_EDMD %>%
  summarise(
    "Éoliennes" = sum(nbr_eolienne, na.rm = TRUE),
    "Hydroélectricité" = sum(nbr_instal_hydroelec, na.rm = TRUE),
    "Installations fossiles" = sum(nbr_inst_fossile, na.rm = TRUE),
    "Incinérateurs" = sum(nbr_incinerateur, na.rm = TRUE),
    "Chaufferies bois" = sum(nbr_chaufferie_bois, na.rm = TRUE),
    "Méthaniseurs" = sum(nbr_unite_methaniseur, na.rm = TRUE),
    "Solaire photovoltaïque" = sum(nbr_inst_sol_photovoltaique, na.rm = TRUE)
  ) %>%
  pivot_longer(cols = everything(), names_to = "Type", values_to = "Total") %>%
  mutate(
    Pourcentage = Total / sum(Total),
    Etiquette = paste0( percent(Pourcentage, accuracy = 1))
  )

# Palette de couleurs personnalisée
couleurs <- c(
  "Éoliennes" = "#66c2a5",
  "Hydroélectricité" = "#3288bd",
  "Installations fossiles" = "#d53e4f",
  "Incinérateurs" = "pink",
  "Chaufferies bois" = "#abdda4",
  "Méthaniseurs" = "#e6f598",
  "Solaire photovoltaïque" = "#fee08b"
)


# Création du camembert avec ggplot2
ggplot(df_pie_installation, aes(x = "", y = Total, fill = Type)) +
  geom_col(color = "white", width = 1) +  # Bordures blanches pour meilleure segmentation
  geom_text(aes(label = Etiquette), position = position_stack(vjust = 0.5), size = 4) +

  coord_polar(theta = "y") +
  scale_fill_manual(values = couleurs) +
  theme_void() +
  theme(legend.title = element_blank())
  

```

```{r}

nbr_install= c("cp_EDMD", "nbr_eolienne",  "nbr_instal_hydroelec", 
               "nbr_inst_fossile", "nbr_incinerateur", "nbr_chaufferie_bois", 
               "nbr_unite_methaniseur", "nbr_inst_sol_photovoltaique")

df_fonds_EDMD[, nbr_install[2:length(nbr_install)]] %>% sum()


repr_matrice_cor(data= df_fonds_EDMD, col_select = nbr_install)
```

```{r}

repr_boxplot_multiple(data= df_fonds_EDMD, 
                      col_select= c("MC_industrie_mwh", "MC_agricole_mwh", "MC_tertiaire_mwh", "MC_residentiel_mwh"), 
                      coord_cart= 2000,
                      y_lib= "Valeur moyenne de la consommation")

repr_matrice_cor(data= df_fonds_EDMD, col_select = c("cp_EDMD", "MC_industrie_mwh", "MC_agricole_mwh", "MC_tertiaire_mwh", "MC_residentiel_mwh"))

```

```{r, message= FALSE}

df_long <- df_fonds_EDMD %>% dplyr::select(taux_conformite_bact,taux_conformite_chim) %>%
  pivot_longer(cols = everything(), names_to = "variable", values_to = "valeur")

# Histogramme avec ggplot2
ggplot(df_long, aes(x = valeur, fill = variable)) +
  geom_histogram(alpha = 0.5, position = "identity", bins = 30) +
  theme_minimal() +
  labs(x = "Taux de conformité", y = "Nombre de commune")

repr_boxplot(data=df_fonds_EDMD, var_fact= "climat", compare_var= "cp_EDMD",clr= c("#FF9999", "#66B2FF", "beige"), coord_y_val= 7e+05)

repr_matrice_cor(data= df_fonds_EDMD, col_select = c("cp_EDMD", "friches", "part_residences_secondaires",
                                                     "taux_conformite_bact","taux_conformite_chim"))

```

```{r}
repr_boxplot(data=df_fonds_EDMD, var_fact= "gridens7", compare_var= "cp_EDMD",clr= c("#FF9999", "#66B2FF", "beige", 6, 2, 3, 4), coord_y_val= 1e+08)

repr_boxplot(data=df_fonds_EDMD, var_fact= "beneficiaire_prog", compare_var= "cp_EDMD",clr= c("gray", "#66B2FF" ), coord_y_val= 1e+05)

repr_matrice_cor(data= df_fonds_EDMD, col_select = c("cp_EDMD", "p_pop", "nb_actes_france_renov", "abstention_municipales", "CSP_maire"))

```

```{r}

repr_matrice_cor(data= df_fonds_EDMD, col_select = c("cp_EDMD", "part_actifs", "part_inactifs", 
                                                     "taux_creation_ent", "total_entreprises", 
                                                     "part_licencies_sportifs", "part_jeunes_sans_diplome"
))

```

```{r, message= FALSE}

repr_boxplot(data=df_fonds_EDMD, var_fact= "gare_tgv", compare_var= "cp_EDMD",clr= c("#FF9999", "#66B2FF", "beige"), coord_y_val= 5e+07)
repr_matrice_cor(data= df_fonds_EDMD, col_select = c("cp_EDMD", "part_trajets_voiture"))



```

```{r}

df_vl_benef <- df_fonds_EDMD %>% dplyr::select(autres_benef_collectivite, autres_benef_entreprise, 
                                              autres_benef_etat, autres_benef_association) %>%
  pivot_longer(cols = everything(), names_to = "variable", values_to = "valeur")

ggplot(df_vl_benef, aes(x = variable, y = valeur, color = variable)) +
  geom_violin(trim = FALSE) +
  geom_jitter(width = 0.2, alpha = 0.3) +
  coord_cartesian(ylim = c(0, 50)) +
  theme_minimal()

repr_boxplot_multiple(data= df_fonds_EDMD, 
                      col_select= c("autres_benef_collectivite","autres_benef_entreprise", 
                                    "autres_benef_etat", "autres_benef_association"), 
                      coord_cart= 40,
                      y_lib= "Nombre de bénéficiaire")


repr_matrice_cor(data= df_fonds_EDMD, col_select = c("cp_EDMD",  "autres_benef_collectivite", 
                                                     "autres_benef_entreprise", "autres_benef_etat", "autres_benef_association","taux_subvention"))




```

```{r}
ae_var= c("cp_EDMD", "ae_AAFAR", "ae_AF", "ae_AGTE", "ae_APD", "ae_CCSR", "ae_CT", "ae_culture", 
          "ae_DAG", "ae_economie", "ae_EDMD", "ae_ES", "ae_GFP", "ae_GPIE", "ae_IAI", 
          "ae_justice", "ae_MLIC", "ae_PR", "ae_RCT", "ae_RD", "ae_RES", "ae_securites", 
          "ae_SIEC", "ae_SJVA", "ae_TEAMS", "ae_TFP")


repr_matrice_cor(data= df_fonds_EDMD, col_select =  ae_var)
```

```{r}
cp_var= c("cp_EDMD", "cp_AAFAR", "cp_AF", "cp_AGTE", "cp_APD", "cp_CCSR", "cp_CT", "cp_culture", 
          "cp_DAG", "cp_economie", "cp_EDMD", "cp_ES", "cp_GFP", "cp_GPIE", "cp_IAI", 
          "cp_justice", "cp_MLIC", "cp_PR", "cp_RCT", "cp_RD", "cp_RES", "cp_securites", 
          "cp_SIEC", "cp_SJVA", "cp_TEAMS", "cp_TFP")

repr_matrice_cor(data= df_fonds_EDMD, col_select =  cp_var)
```

# Statistiques Spatiale

```{r, warning= FALSE, message= FALSE}

# Chargement des données géographiques (communes ou départements)
com <- read_sf("commune_sf")  # ou un autre fichier contenant la géo

# Filtrer uniquement les départements de Bretagne 
bretagne <- com %>% dplyr:: filter(reg == "53") 

colnames(bretagne)[1] = "code_com"

bretagne$code_com = as.double(bretagne$code_com)

df_fonds_EDMD_for_carto = left_join(df_fonds_EDMD, bretagne, by = "code_com")
df_fonds_EDMD_for_carto <- st_as_sf(df_fonds_EDMD_for_carto)


# Tracer uniquement la Bretagne
ggplot(df_fonds_EDMD_for_carto) +
  geom_sf(aes(fill = statut_finance_ecolo_dmd)) +
  scale_fill_manual(
    values = c("0" = "pink", "1" = "turquoise"),
    name = "Statut du bénéficiaire fonds EDMD",
    labels = c("Non", "Oui")
  ) +
#  labs(title = "Répartition des bénéficiaires du fonds écologie \net developpement des mobilitées durables par commune")+
  theme_void() +  coord_sf()


# Tracer uniquement la Bretagne
ggplot(df_fonds_EDMD_for_carto) + 
  geom_sf(aes(fill = cp_EDMD)) + 
scale_fill_continuous(low="beige",high= c("green", "red"))+
  theme_void() +  coord_sf()


# Tracer uniquement la Bretagne
ggplot(df_fonds_EDMD_for_carto) + 
  geom_sf(aes(fill = taux_subvention)) + 
scale_fill_continuous(low="beige",high="blue")+
  theme_void() +  coord_sf()

df_fonds_EDMD %>% dplyr::select(statut_finance_ecolo_dmd) %>%
  summary()

```

```{r}
library(dplyr)


planar_sf_breizh<-st_transform(df_fonds_EDMD_for_carto , 2154)

centroids_benef <- st_centroid(df_fonds_EDMD_for_carto %>% dplyr::filter(statut_finance_ecolo_dmd==1))

planar_center_com_breizh <-st_transform(centroids_benef, 2154)

ppp_points_breizh <- as.ppp(st_coordinates(planar_center_com_breizh),as.owin(planar_sf_breizh))
ds_breizh <- density(ppp_points_breizh) #sample version
plot(ds_breizh, main= "")
```

```{r}
xy <- cbind(x=df_fonds_EDMD$p_pop, y=df_fonds_EDMD$taux_subvention)

plot(xy, cex=cible_var/1e+08, xlim=c(0,25000), ylim=c(0,0.9), col=rev(terrain.colors(50)))
```

```{r, warning= FALSE, message= FALSE}
df_fonds_EDMD[df_fonds_EDMD$taux_subvention >0.85,]%>%
  dplyr::select(lib_com, taux_subvention, p_pop, superf_choro) %>%
  arrange(desc(taux_subvention))
```

```{r}
df_fonds_EDMD_for_carto <- st_transform(df_fonds_EDMD_for_carto, crs = 4326)  # reprojection

df_fonds_EDMD_for_carto$cp_EDMD <- as.numeric(df_fonds_EDMD_for_carto$cp_EDMD)
```

![](images/contiguite.png)

![](images/contiguite_queen.png)

```{r, warning= FALSE, message= FALSE}

### Récupération des centroides 
coor<-st_centroid(st_geometry(df_fonds_EDMD_for_carto))

#Extraction de la liste des voisins (au sens Queen par défaut)
communes_link_queen <- poly2nb(df_fonds_EDMD_for_carto, queen= TRUE)

card_communes_link_queen<-card(communes_link_queen)

tmap_mode("plot") 

tm_shape(df_fonds_EDMD_for_carto) +
  tm_polygons(col="white", border.col = "blue") +
  tm_graticules(lines = FALSE) +
  tm_shape(st_centroid(df_fonds_EDMD_for_carto)) +
  tm_dots(size = 0.1, col="green") +
  tm_shape(nb2lines(communes_link_queen, coords=coor)) +
  tm_lines(col="red", lwd=0.3) +
  tm_layout(title ="Voisins contigus (Queen)",title.position = c('left', 'bottom'),scale=0.5)
```

```{r}
ggplot() +
  geom_density(aes(x=card_communes_link_queen)) +
  xlab("Nombres de voisins")+ggtitle("Voisins contigus (Queen)")
```

-   Analyse de la configuration des points

```{r}

planar_sf_breizh_KS<-st_transform(df_fonds_EDMD_for_carto , 2154)

centroids_benef_KS <- st_centroid(df_fonds_EDMD_for_carto)

planar_center_com_breizh_KS <-st_transform(centroids_benef, 2154)

ppp_points_breizh_KS <- as.ppp(st_coordinates(planar_center_com_breizh),
                               as.owin(planar_sf_breizh))
ds_breizh_KS <- density(ppp_points_breizh)

####################################################################

centroids_benef_ponct <- st_centroid(df_fonds_EDMD_for_carto %>%
                                       dplyr::filter(statut_finance_ecolo_dmd==1))

planar_center_com_breizh_ponct <-st_transform(centroids_benef, 2154)

planar_sf_breizh_KS_ponct<-st_transform(df_fonds_EDMD_for_carto %>%
                                    dplyr::filter(statut_finance_ecolo_dmd==1),
                                  2154)

ppp_points_breizh_KS_ponct <- as.ppp(st_coordinates(planar_center_com_breizh_ponct),
                                     as.owin(planar_sf_breizh_KS_ponct))

KS.test <- cdf.test(ppp_points_breizh_KS_ponct, ds_breizh_KS, test="ks")
KS.test
```

```{r, message=FALSE, warning= FALSE}

pts_eco <- st_as_sf(
    st_centroid(df_fonds_EDMD_for_carto %>% dplyr:: filter(statut_finance_ecolo_dmd==1)),
    coords = c("xcl2154","ycl2154"),
    crs    = 2154,
    remove = FALSE) %>%
  st_transform(2154)


par(mar = c(0, 0, 1, 0))
plot(
  st_geometry(bretagne),
  col    = "lightgrey",
  border = "darkgrey",
  main   = ""
  )

plot(
  pts_eco,
  pch = 20, cex= 0.4,  col =  "black",
  add = TRUE)
```

# Autocorrélation spatiale globale

```{r, message=FALSE, warning= FALSE}

# Représentation du diagramme de Moran

#Création de la matrice de poids standardisé en ligne = méthode par défaut
W_Queen <- nb2listw(communes_link_queen ,zero.policy=TRUE,style="W")
m1 <- listw2mat(W_Queen)

#Calcul des fonds écologie et developpement durable standardisés
df_fonds_EDMD_for_carto$cp_EDMD_std <- as.vector(scale(df_fonds_EDMD_for_carto$cp_EDMD))

# Représentation cartographique du diagramme de Moran


#revenu médian des voisins (Wy)
df_fonds_EDMD_for_carto$v_cp_EDMD_std<-lag.listw(W_Queen,df_fonds_EDMD_for_carto$cp_EDMD_std)

#Variable indicatrice (high high, low low ect)
df_fonds_EDMD_for_carto$hs[df_fonds_EDMD_for_carto$v_cp_EDMD_std<mean(df_fonds_EDMD_for_carto$cp_EDMD_std) & df_fonds_EDMD_for_carto$cp_EDMD_std<mean(df_fonds_EDMD_for_carto$cp_EDMD_std)]<-1.0
df_fonds_EDMD_for_carto$hs[df_fonds_EDMD_for_carto$v_cp_EDMD_std>=mean(df_fonds_EDMD_for_carto$cp_EDMD_std) & df_fonds_EDMD_for_carto$cp_EDMD_std<mean(df_fonds_EDMD_for_carto$cp_EDMD_std)]<-2.0
df_fonds_EDMD_for_carto$hs[df_fonds_EDMD_for_carto$v_cp_EDMD_std<mean(df_fonds_EDMD_for_carto$cp_EDMD_std) & df_fonds_EDMD_for_carto$cp_EDMD_std>=mean(df_fonds_EDMD_for_carto$cp_EDMD_std)]<-3.0
df_fonds_EDMD_for_carto$hs[df_fonds_EDMD_for_carto$v_cp_EDMD_std>=mean(df_fonds_EDMD_for_carto$cp_EDMD_std) & df_fonds_EDMD_for_carto$cp_EDMD_std>=mean(df_fonds_EDMD_for_carto$cp_EDMD_std)]<-4.0

brks <- c(1,2,3,4)
colors <- rev(brewer.pal(n = 4, name = "RdYlBu"))

#diagramme de Moran
# args(moran.plot)
par(mfrow= c(1,2))
par(mar = c(0, 0, 1, 0))
moran.plot(df_fonds_EDMD_for_carto$cp_EDMD_std ,
           W_Queen,labels=TRUE, pch = ".",
           xlab="Fonds écologie et développement durable",ylab="Moyenne des fonds écologie et développement durable")

par(mar = c(0, 0, 1, 0))
plot(st_geometry(df_fonds_EDMD_for_carto),border="lightgray",col=colors[findInterval(df_fonds_EDMD_for_carto$hs,brks,all.inside=FALSE)]
     #, main= "Cartographie du diagramme de Moran"
     )
legend("bottomleft", legend = c('BB','BH','HB','HH'),
       fill=colors,bty="n")

```

```{r, warning= FALSE, message= FALSE}
moran.test(df_fonds_EDMD_for_carto$cp_EDMD_std,W_Queen,zero.policy=TRUE, randomisation=FALSE)
```

```{r}
moran.test(df_fonds_EDMD_for_carto$cp_EDMD_std, W_Queen,zero.policy=TRUE, randomisation=TRUE)
```

# Autocorrélation spatiale locale

```{r}
library(spdep)


# Autocorélation local
lisa_cp_EDMD<- localmoran(df_fonds_EDMD_for_carto$cp_EDMD,W_Queen,zero.policy=TRUE)

local_moran <- localmoran(df_fonds_EDMD_for_carto$cp_EDMD_std, W_Queen, zero.policy = TRUE)
pval <- local_moran[, "Pr(z != E(Ii))"]

# significance threshold
signif <- 0.05 

var_std<-df_fonds_EDMD_for_carto$cp_EDMD_std

# centers the local Moran's around the mean
local<-lisa_cp_EDMD[,1]-mean(lisa_cp_EDMD[,1])

# Construction d’un data.frame pour le scatterplot
moran_df <- data.frame(
  var_std = var_std,
  local = local,
  pval = pval
)

# Typologie selon quadrants
moran_df <- moran_df %>%
  mutate(cadrant = case_when(
    var_std > 0 & local > 0 & pval <= signif ~ "haut-haut",
    var_std < 0 & local < 0 & pval <= signif ~ "bas-bas",
    var_std > 0 & local < 0 & pval <= signif ~ "haut-bas",
    var_std < 0 & local > 0 & pval <= signif ~ "bas-haut",
    TRUE ~ "Non significatif"
  ),
  brks = case_when(
    var_std > 0 & local > 0 & pval <= signif ~ 4,
    var_std < 0 & local < 0 & pval <= signif ~ 1,
    var_std > 0 & local < 0 & pval <= signif ~ 3,
    var_std < 0 & local > 0 & pval <= signif ~ 2,
    TRUE ~ 0
  ),
  colors = case_when(
    var_std > 0 & local > 0 & pval <= signif ~ "red",
    var_std < 0 & local < 0 & pval <= signif ~ "blue",
    var_std > 0 & local < 0 & pval <= signif ~ "orange",
    var_std < 0 & local > 0 & pval <= signif ~ "lightblue",
    TRUE ~ "lightgray"
  ))

par(mfrow= c(1,2))
par(mar = c(0, 0, 1, 0))

# Créer le plot de base
plot(
  moran_df$var_std, moran_df$local,
  col = moran_df$colors,
  pch = 19,
  xlab = "Valeur standardisée des cp_EDMD",
  ylab = "Moyenne pondérée des voisins",
  main = ""
)

# Lignes horizontale et verticale
abline(h = 0, lty = 2, col = "black")
abline(v = 0, lty = 2, col = "black")



## carte I Moran locaux

# quadrant <- vector(mode="numeric",length=nrow(lisa_cp_EDMD))
# 
# # builds a data quadrant
# quadrant[var_std>0 & local>0  & lisa_cp_EDMD[,5] < signif] <- 4  
# quadrant[var_std <0 & local<0 & lisa_cp_EDMD[,5] < signif] <- 1      
# quadrant[var_std <0 & local>0 & lisa_cp_EDMD[,5] < signif] <- 2
# quadrant[var_std >0 & local<0 & lisa_cp_EDMD[,5] < signif] <- 3
# quadrant[lisa_cp_EDMD[,5]>signif] <- 0   
# 
# # plot in r
# brks <- c(0,1,2,3,4)
colors_leg <- c("lightgray","blue","lightblue","orange","red")

par(mar = c(0, 0, 1, 0))
plot(st_geometry(df_fonds_EDMD_for_carto),border="white",col=moran_df$colors)

legend("bottomleft", legend = c("non significatif","bas-bas","bas-haut","haut-bas","haut-haut"),
       fill= colors_leg,bty="n")

```

```{r}
# Calcul de la densité
dens <- density(lisa_cp_EDMD[, 1])

# Tracé de la courbe
plot(dens,
     main    = "",
     xlab    = "Indices de Moran local (LISA)",
     ylab    = "Densité",
     lwd     = 2
)

# Ajout du trait vertical rouge à x = 0.08
abline(v = 0.08, col = "red", lwd = 2)

# Ajout du texte pour indiquer que c'est le I de Moran global
text(x = 0.08, 
     y = max(dens$y) * 0.9, 
     labels = "I de Moran global", 
     pos = 4, 
     col = "red")


```

```{r,message=FALSE, warning= FALSE}

repr_ppp= function(data, filiere_choice, process= Kest){
  
  data= data %>% filter(filiere== filiere_choice) 
  #Création d’un point pattern ppp= representing a point pattern dataset in the two-dimensional plane, avec owin la zone d’étude
 
  ppp_filiere <- as.ppp(data[ ,c ("lambert_x", "lambert_y")],
                        owin(c(min(data[,"lambert_x"]),
                               max(data[,"lambert_x"])),
                             c(min(data[,"lambert_y"]),
                               max(data[,"lambert_y"])))
                        )
  
  # K inhomogène avec  l'enveloppe
  kenv_filiere <- envelope(ppp_filiere, process)
  
  #représentation graphique
  plot(kenv_filiere, main= filiere_choice, xlab = "r (mètres)")
}


centroids <- st_centroid(df_fonds_EDMD_for_carto %>% dplyr:: filter(statut_finance_ecolo_dmd==1))

data_for_ppp        <- data.frame(st_coordinates(centroids))
colnames(data_for_ppp)= c("lambert_x", "lambert_y")

data_for_ppp$filiere= "KinEDMD"



```

```{r}
repr_ppp(data= data_for_ppp, filiere_choice= "KinEDMD")


```

# Machine learning et modeles de prédiction

```{r}
library(stars)
raster_planar<-st_rasterize(planar_sf_breizh) #créer un raster à partir de notre objet sf
plot(raster_planar['cp_EDMD', ])
```

```{r}
variable <-as.im(raster_planar['cp_EDMD',]) # le raster a plusieurs variables, choisir le cp_EDMD

modele_cp_EDMD<-ppm(ppp_points_breizh~ variable) #Modèle de poisson de notre processus ponctuel expliqué par le fonds_cp_EDMD
modele_cp_EDMD 
```

```{r}
#plot(effectfun(modele_cp_EDMD, "variable", se.fit = TRUE),legend = FALSE)
plot(predict(modele_cp_EDMD), main = "Prédictions" ,col=col)
```

```{r}
model_intercept <- ppm(ppp_points_breizh ~ 1)  #Null model
anova(model_intercept, modele_cp_EDMD, test = "LRT") # Compare null to population model
```

# ANNEXE

```{r}
#[1] "Installation solaire photovoltaïque" "Unité de méthanisation"              "Chaufferie bois"                     "Installation fossile"               
#[5] "Eolienne"                            "Installation hydroélectrique"        "Incinérateur"  

loc_prod_energie= read.csv("/home/emiliano/Documents/MASTER_MAS/ALTERNANCE/FONDS VERT/DATA_PRETREATMENT/loc_prod_energie.csv", sep = ",", dec= ",")


pts_eco_eolienne <- st_as_sf(
    loc_prod_energie %>% filter(filiere==  "Installation solaire photovoltaïque" ),
    coords = c("lambert_x","lambert_y"),
    crs    = 2154,
    remove = FALSE)

planar_sf_breizh_eol<-st_transform(df_fonds_EDMD_for_carto, 2154)
planar_center_com_breizh_eol <-st_transform(pts_eco_eolienne, 2154)
ppp_points_breizh_eol <- as.ppp(st_coordinates(planar_center_com_breizh),as.owin(planar_sf_breizh))
ds_eol <- density(ppp_points_breizh) #sample version
plot(ds_eol, main="Densité d'installation solaire photovoltaïque en Bretagne")
```

```{r,message=FALSE, warning= FALSE}

# limite admin. de la Bretagne  66> utilise internet pour charger le paquet 
gadm1 <- geodata::gadm(country = "FRA", level = 1, path = tempdir())
regions <- st_as_sf(gadm1)

#filtrer et reprojection en 2154
bretagne <- regions %>%
  filter(NAME_1 == "Bretagne") %>%
  st_transform(2154)
  
  
prod_energie_breizh= function(data, filiere_choice, region){
  
  filieres <- unique(data$filiere)
  n       <- length(filieres)
  cols    <- brewer.pal(n, "Set1")
  names(cols) <- filieres

  pts_eco <- st_as_sf(
      data %>% filter(filiere== filiere_choice),
      coords = c("lambert_x","lambert_y"),
      crs    = 2154,
      remove = FALSE
    )
  
  
  
  # tracé
  par(mar = c(0, 0, 1, 0))
  plot(
    st_geometry(bretagne),
    col    = "lightgrey",
    border = "darkgrey",
    main   = filiere_choice
    )
  plot(
    pts_eco,
    pch = 20, cex= 0.4,  col =  cols[filiere_choice],
    add = TRUE)}


#Représentation spatial

par(mfrow=c(2,2), las=1)


  
for (filiere in c(unique(loc_prod_energie$filiere))){
  prod_energie_breizh(data= loc_prod_energie, filiere_choice= filiere, region= bretagne)
}

```

```{r}
for (filiere in c(unique(loc_prod_energie$filiere))){
  repr_ppp(data= loc_prod_energie, filiere_choice= filiere)
}
for (filiere in c(unique(loc_prod_energie$filiere))){
  repr_ppp(data= loc_prod_energie, filiere_choice= filiere, process= Kinhom)
}
```

## Relation entre les individus(communes) et relation entre variables explicatives

En raison du nombre important de variable la solution de la visualisation de la coorélation des variables dans leurs ensembles n'est pas adéquat car il génére une visualisation peu exploitable ou non interpretable et illisible. Une etude des relation à l'échelle des variables et celle des individu est mise au point sur la base d'utilisation de méthode linéaire et non linéaire à but distinct.

-   Méthodes linéaires et interpretable: **ACP**

L'Analyse en composante principale est une methode linéaire utilisé pendant l'analyse descriptive des données qui vise à retrouver les différente relation entre les variables. A défaut de faire une visualisation graphique de la matrice de correlation pour l'ensemble des variables de notre bases de données qui pourrait s'avérer très rapidement ilisible voir non interpretale nous avons décidée de faire une visualisation grace à l'ACP.

-   **Choix des axes de représentation** :

A travers le Tableau simplifier des valeurs propres qui accompagne l'acp on constate que les deux premier axes constitue les axes possedant les deux plus grand pourcentage d'inertie comparativement aux autres axes. Ce qui pousse notre choix de visualisation vers ces deux axes.

```{r, warning= FALSE, message= FALSE}
# Nettoyage des données
df_clean_EDMD <- na.omit(df_fonds_EDMD %>%
  dplyr::select(-c("code_com","code_dept","code_arr","lib_com","lib_arr","lib_dept")) )

# Conversion des colonnes en numérique
df_clean_EDMD_for_PCA <- df_clean_EDMD %>%
  mutate(across(c(gridens7, gare_tgv, ecoquartiers, climat, beneficiaire_prog, statut_finance_ecolo_dmd), as.numeric))

acp_basic <- prcomp(df_clean_EDMD_for_PCA, scale. = TRUE)
# 5. Consulter le tableau des valeurs propres
eig <- get_eigenvalue(acp_basic)

```

Aussi pour la visualisation des ACP sur les deux premiers axes nous avons procèder par tranche d'intervalle de contribution afin d'avoir un visuel plus claire en raison du nombre de variable.

```{r, warning= FALSE, message= FALSE}
# Analyse en composantes principales
acp <- PCA(df_clean_EDMD_for_PCA, graph = FALSE)


acp_seg_contrib= function(acp_values,min_contrib, max_contrib= -1){
  
# Extraire les contributions
var_contrib <- acp_values$var$contrib

#rownames(var_contrib) = 1: length(rownames(var_contrib))

# Sélectionner les variables ayant une contribution appartenant à [min_contrib, max_contrib]  sur le plan (axe 1 et 2)

if(max_contrib !=  -1){selected_vars <- which(rowSums(var_contrib[, 1:2]) <= max_contrib & rowSums(var_contrib[, 1:2]) > min_contrib)}else{
  selected_vars <- which(rowSums(var_contrib[, 1:2]) >= min_contrib)
  }


print(rownames(var_contrib)[selected_vars])

# Visualiser uniquement ces variables
return(fviz_pca_var(acp_values,
             axes = c(1,2),
             select.var = list(name = rownames(var_contrib)[selected_vars]),
             col.var = "contrib",
             gradient.cols = c("blue", "yellow", "red"),
             repel = TRUE))
}
```

-   Intervales de contribution $[0 , 0.5]$ et $[0.5, 1]$

```{r, warning= FALSE, message= FALSE}
acp_seg_contrib(acp_values= acp, min_contrib= 0, max_contrib= 0.5)
acp_seg_contrib(acp_values= acp, min_contrib= 0.5, max_contrib= 1)
```

D'après les deux première intervalles aucunes des variables afficher ne sont bien représenter sur les deux premières axe exepter les variables "ecoquartiere" et "nbr_incinérateur" qui sont un peu mieux représenter par l'axe 1. Grace à l'angle fermer qu'engendre leurs deux vecteurs représentatif partant de l'origine du cercle on peut dire que ces deux variables sont correlé et donc le fait qu'un quartier soit un ecoquartier ou pas pouyrrait etre impactant dans son rapport avec la production d'énergie par incinération.

-   Intervales de contribution $[1, 1.5]$

```{r, warning= FALSE, message= FALSE}
acp_seg_contrib(acp_values= acp, min_contrib= 1, max_contrib= 1.5)
```

Dans cette intervalle les variables **cp_justice**, **ae_justice**, **ae_EDMD** et **cp_aide_publique_au_developpement** sont très bienb représenté dans le mapping et spécifiquement par l'axe 1. Ces vecteur forme des angle assez fermer ce qui impliquerai une certaine correlation entre ceux ci. D'après cette visualisation nous pourions affirmer que les fonds relatives aux thématiques relative à la justice , à l'aide publique au developpement et à l'aide publique au developppement serai corrélé. Les autres variables Présente sur ce maping ne sont pas bien représenté au vue des axes choisis.

-   Intervales de contribution $[1.5, 2]$

```{r, warning= FALSE, message= FALSE}
acp_seg_contrib(acp_values= acp, min_contrib= 1.5, max_contrib= 2)
```

Ici nous identifions deux groupe de variable à forte contribution assez bien représenté dans le mappin(proximita des vecteur avec l'arc de cercle et axe) et principalement par l'axe 1. Dans le premier groupe on trouve les variable telle que le financement basé sur la thématiques cohesion du territoire, enseignement scolaire et les variable relative au nombre d'établissement dans les domaine telle que l'information et la communication , les établissament d'activité scientifique et technique du service administraqtive, les établissement financière et asssurance et la variable relative au nombre total d'autre type de bénéficiaire des aides de l'état dans les collectivité. Ces varfiable serait fortement correlé d'après leur ACP.

Dans le second groupe de variable nous avons les variable relative au mlontant liée au thématiques de financement telle que le sport jeunesse et vie associative , l'administration générale territoriale de l'Etat. Les vecteurs représentatif de ces variable forment entre elles des angles très fermer et donc une notion de proximité associable à une forte correlation entre elle et aussi le sens et al direction de ces vecteur rejoigne celle de notre variable cible **cp_EDMD** visualisé dans l'ACP des variable ayant un intervale de contribution comprise en et 1 et 1.5 et donc ceux ci serait corellé avec notre variable cible

-   Intervales de contribution $[2, 2.5]$

```{r, warning= FALSE, message= FALSE}
acp_seg_contrib(acp_values= acp, min_contrib= 2, max_contrib= 2.5)
```

L'intervalle de contribution 2 à 2.5 de l'ACP nous permet de visualiser un mapping surlequel nous pouvons disposé deux groupes de variablrs dont la premiere est constitue de variabe telle que la part d'actifs , le nombre d'établissement publique d'enseignement , de santé et d'azction sociale, le nombre d'établisssement de commerce transport hebergeemnt et restauration, d'activité immobilières et des autres activité de services,les variables relative au nombre de popopulation et du nombre total d'entreprises. Ces variables sont corrélé et ont une fortes contribution pour les axes choixi.

Le second groupe est composé des vetceurs représentative des variables relative au financement des thématique telle qie les thématiques relative à la securité , les relations collectives territoriales, les recherche dans l'enseignement superieur, la culture et l'administration generale territoriale d'état, enfin nous avons la variable relative au nombre total des autres bénéficiaire des financement de l'Etat. Ce groupe est indépendant par rapport à la variable relative au statut de financement de l'écologie alors la correlation est nulles entre ces vecteurs.

-   Intervales de contribution $min_contrib >3$

```{r, warning= FALSE, message= FALSE}
acp_seg_contrib(acp_values= acp, min_contrib= 2.5)
```

Dans cette derniere intervalle de contribution nous détectons 3 groupe de vecteur dont la première est constitué du taux ded subvention et du nombre d'élu locaux(CSP maire) dans la commune.Leurs deux vecteurs représentatif forme un angle quasiment fermer et sont un peu mieu représenté par l'axe 2 que l'axe 1. Ces vecteurs serait corrélé entre eux et en sens opposé de ces vecteurs nous avons le vecteur représentatif de la variable grdens7 qui évalue les densités en population de la commune sur une échelle de 7. L'opposition de ce vecteur pourrai etre interprété comme une correlation négative de celuici aux vecteur du premier groupe. Ensuite le secons groupe est constitué de variable que avec des vecteurs représentatif très bien représenter dans le mapings et resultante d'une des deux premier axe de l'ACP avec une influence modérere de l'axe 1 et constitué de vecteur représentatif de variable telle le nombres d'actes france_renov, le nombre de friches, le nombre d'établisssement industriel,la part de licencies sportifs, les emissions de GES et le nombre d'etablissement de construction. Ces vecteur forment entre elle des angles très fermé création ainsi une possibilité de fote corrélation entre ces vecteurs.

Enfin un dernier groupe de vecteur représentatif dans un premier temps par des variable des fonds basé sur des thématiques relative à l'action du gouvernement, à la gestion des finances publiques, aux medias livre et industries culturelles, à la sécurité,à l'économie, aux travail et emploi dans l'administration et aux ministeres sociaux, aux transfoemation de la fonction publique, aux controle de circulation et stationnement routiers, et dans un secons temps par des variables telle que le nombre d'instatalation photovoltaique , du nombre de chaufferie boiset à la moyenne de la consommation résidentiel apr habitant. Les vecteurs représentatif de ces variables sont très proches du cercle et possède une forte contribution et mieux représenté par l'axe 1 que que par l'axe 2 en étant perpendiculaire au vecteur du premier groupe et au vecteur représentatif gridens7 on peux dire que ces variables sont indépendante et donc ont une corrélation nulles.

```{r, warning= FALSE, message= FALSE}

# Réaliser l'ACP
acp <- prcomp(df_clean_EDMD_for_PCA, scale. = TRUE)

# Visualisation avec les individus colorés selon l'espèce
fviz_pca_ind(acp, 
             axes= c(1, 2),
             habillage = df_clean_EDMD_for_PCA$statut_finance_ecolo_dmd,
             addEllipses = TRUE,
             label = "none",
             palette = "jco",
             title = "ACP des données à l'échelle des individus")

```

-   Méthode non linéaire et exploratoire: **UMAP**

Nous avons décider alors de visualisé une apperçu UMap de nos données prétraiter dans un premier temps

```{r, warning= FALSE, message= FALSE}
# Garder uniquement les colonnes numériques
df_numeric <- df_clean_EDMD[, sapply(df_clean_EDMD, is.numeric)]

# Supprimer lignes avec NA ou Inf
df_numeric <- df_numeric[complete.cases(df_numeric), ]
df_numeric <- df_numeric[apply(df_numeric, 1, function(row) all(is.finite(row))), ]

# Supprimer colonnes à variance nulle (problème pour scale())
df_numeric <- df_numeric[, apply(df_numeric, 2, function(col) sd(col, na.rm = TRUE) > 0)]

# Standardisation
df_scaled <- scale(df_numeric)

# Supprimer les doublons
df_scaled_unique <- df_scaled[!duplicated(df_scaled), ]

# UMAP
head(df_scaled_unique)
umap_result <- umap(df_scaled_unique)

# Affichage
umap_df <- data.frame(X = umap_result$layout[,1], Y = umap_result$layout[,2])
ggplot(umap_df, aes(X, Y)) +
  geom_point(color = "forestgreen", alpha = 0.6) +
  ggtitle("Projection UMAP") +
  theme_minimal()

```

D'après la représentation UMAP, le visuelle résultant ne révèle pas de groupes clairs, On pourrait pensé que cela pourrai venir du fait qu'il n'y as pas de cluster naturel mais cela pourrait d'autant plus s'expliquer par le faite que les données serait extremmement bruités.A cette effet nous avons donc mis en place une détection des relations sous jacentes entres les individus à travers le couplage UMAP et HDBSCAN avec DBSCAN un algorithme de machine learning non supervisé. Nous avons choisis particulièrement DBSCAN car c'est utile quand les groupes ont des formes irrégulières ou une taille inégale et cela pourrait s'avérer interessant.

```{r, warning= FALSE, message= FALSE}
umap_df <- data.frame(X = umap_result$layout[,1], Y = umap_result$layout[,2])

# HDBSCAN (minPts = minimum nombre de points pour former un cluster)
hdb_result <- hdbscan(umap_df, minPts = 33)

# Ajouter les clusters au DataFrame
umap_df$Cluster <- as.factor(hdb_result$cluster)  # 0 = bruit


ggplot(umap_df, aes(X, Y, color = Cluster)) +
  geom_point(size = 2, alpha = 0.8) +
  scale_color_manual(values = c("0" = "gray","1"= "blue","2"= "red")) +
  ggtitle("Projection UMAP + HDBSCAN Clustering") +
  theme_minimal()

```

**Breve résumé statistique de la sortie UMAP + DBSCAN**

```{r, warning= FALSE, message= FALSE}
summary(umap_df)
```

Nous obtenons une distinction de 2 différent groupe dont le groupe 2 qui est majoritaire en contenant le plus d'individu que le groupe 1 qui sont dans le meme temps est assez bien séparer par les bruits. Le Cluster 0 sont considérés comme bruit/anomalie par HDBSCAN, ici il sont distribuer de façon dispercer en s'intercallent entre le premier et le deuxxiemme groupe. Pour obtenir ces trois groupe nous avons choisis la valeur de paramètre **minpts** du DBSCAN égale à 33 car nous avopns constaté que en dessous de cette valeur nous obtenons beaucoup plus de cluster et difficile a distinguer et difficilement ou voir pas interpretable car ne sont pas réparti de façon a ce qu'on les distingue correctement et au dessus de la valeur 120 du **minpts** une seul unique cluster est crée tout bruit confondu. Ces groupes serait donc éventuellement comparable ou identifiable à notre variable d'interet relative au statut des commune concernant la demande de financement du fonds vert. Avec pour correspondance le groupe 1 qui constitue approximativement 1/4 des du groupe 2 et comme étant celui des communes demandeur et le groupe 2 comme étant les communes qui n'ont pas fait de demande de fonds vert.

## Estimation du Modèle logistique et justification de la spécification du modèle

-   **Modele logistique par selection backward de variable**

Nous avons éffectuer un pré-traitement spécifique de données pour leurs utilisation des les modèle de machine learning notamment sur les questions liées à la dépendance de certaines variable et la dummisation des variables qualitatif. Ci dessous une liste des groupes de colonnes linéairement dépendante :

```{r, warning= FALSE, message= FALSE}

# Exemple avec des données numériques
mat <- model.matrix(~ ., data = df_clean_EDMD)[, -1]  # On enlève l'intercept

# Trouve les combinaisons linéaires
combos <- findLinearCombos(mat)

# visualisation des colonnes indépendantes

for(i in 1:length(combos$linearCombos)){

  print(colnames(mat)[combos$linearCombos[[i]]])
  print("-----------------------------------------")
}
```


