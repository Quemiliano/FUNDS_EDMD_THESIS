par(mar = c(0, 0, 1, 0))
moran.plot(df_fonds_EDMD_for_carto$cp_EDMD_std ,
W_Queen,labels=TRUE, pch = ".",
xlab="Fonds écologie et développement durable",ylab="Moyenne des fonds écologie et développement durable")
par(mar = c(0, 0, 1, 0))
plot(st_geometry(df_fonds_EDMD_for_carto),border="lightgray",col=colors[findInterval(df_fonds_EDMD_for_carto$hs,brks,all.inside=FALSE)]
#, main= "Cartographie du diagramme de Moran"
)
legend("bottomleft", legend = c('BB','BH','HB','HH'),
fill=colors,bty="n")
moran.test(df_fonds_EDMD_for_carto$cp_EDMD_std,W_Queen,zero.policy=TRUE, randomisation=FALSE)
moran.test(df_fonds_EDMD_for_carto$cp_EDMD_std, W_Queen,zero.policy=TRUE, randomisation=TRUE)
library(spdep)
# Autocorélation local
lisa_cp_EDMD<- localmoran(df_fonds_EDMD_for_carto$cp_EDMD,W_Queen,zero.policy=TRUE)
local_moran <- localmoran(df_fonds_EDMD_for_carto$cp_EDMD_std, W_Queen, zero.policy = TRUE)
pval <- local_moran[, "Pr(z != E(Ii))"]
# significance threshold
signif <- 0.05
var_std<-df_fonds_EDMD_for_carto$cp_EDMD_std
# centers the local Moran's around the mean
local<-lisa_cp_EDMD[,1]-mean(lisa_cp_EDMD[,1])
# Construction d’un data.frame pour le scatterplot
moran_df <- data.frame(
var_std = var_std,
local = local,
pval = pval
)
# Typologie selon quadrants
moran_df <- moran_df %>%
mutate(cadrant = case_when(
var_std > 0 & local > 0 & pval <= signif ~ "haut-haut",
var_std < 0 & local < 0 & pval <= signif ~ "bas-bas",
var_std > 0 & local < 0 & pval <= signif ~ "haut-bas",
var_std < 0 & local > 0 & pval <= signif ~ "bas-haut",
TRUE ~ "Non significatif"
),
brks = case_when(
var_std > 0 & local > 0 & pval <= signif ~ 4,
var_std < 0 & local < 0 & pval <= signif ~ 1,
var_std > 0 & local < 0 & pval <= signif ~ 3,
var_std < 0 & local > 0 & pval <= signif ~ 2,
TRUE ~ 0
),
colors = case_when(
var_std > 0 & local > 0 & pval <= signif ~ "red",
var_std < 0 & local < 0 & pval <= signif ~ "blue",
var_std > 0 & local < 0 & pval <= signif ~ "orange",
var_std < 0 & local > 0 & pval <= signif ~ "lightblue",
TRUE ~ "lightgray"
))
par(mfrow= c(1,2))
par(mar = c(0, 0, 1, 0))
# Créer le plot de base
plot(
moran_df$var_std, moran_df$local,
col = moran_df$colors,
pch = 19,
xlab = "Valeur standardisée des cp_EDMD",
ylab = "Moyenne pondérée des voisins",
main = ""
)
# Lignes horizontale et verticale
abline(h = 0, lty = 2, col = "black")
abline(v = 0, lty = 2, col = "black")
## carte I Moran locaux
# quadrant <- vector(mode="numeric",length=nrow(lisa_cp_EDMD))
#
# # builds a data quadrant
# quadrant[var_std>0 & local>0  & lisa_cp_EDMD[,5] < signif] <- 4
# quadrant[var_std <0 & local<0 & lisa_cp_EDMD[,5] < signif] <- 1
# quadrant[var_std <0 & local>0 & lisa_cp_EDMD[,5] < signif] <- 2
# quadrant[var_std >0 & local<0 & lisa_cp_EDMD[,5] < signif] <- 3
# quadrant[lisa_cp_EDMD[,5]>signif] <- 0
#
# # plot in r
# brks <- c(0,1,2,3,4)
colors_leg <- c("lightgray","blue","lightblue","orange","red")
par(mar = c(0, 0, 1, 0))
plot(st_geometry(df_fonds_EDMD_for_carto),border="white",col=moran_df$colors)
legend("bottomleft", legend = c("non significatif","bas-bas","bas-haut","haut-bas","haut-haut"),
fill= colors_leg,bty="n")
# Calcul de la densité
dens <- density(lisa_cp_EDMD[, 1])
# Tracé de la courbe
plot(dens,
main    = "",
xlab    = "Indices de Moran local (LISA)",
ylab    = "Densité",
lwd     = 2
)
# Ajout du trait vertical rouge à x = 0.08
abline(v = 0.08, col = "red", lwd = 2)
# Ajout du texte pour indiquer que c'est le I de Moran global
text(x = 0.08,
y = max(dens$y) * 0.9,
labels = "I de Moran global",
pos = 4,
col = "red")
repr_ppp= function(data, filiere_choice, process= Kest){
data= data %>% filter(filiere== filiere_choice)
#Création d’un point pattern ppp= representing a point pattern dataset in the two-dimensional plane, avec owin la zone d’étude
ppp_filiere <- as.ppp(data[ ,c ("lambert_x", "lambert_y")],
owin(c(min(data[,"lambert_x"]),
max(data[,"lambert_x"])),
c(min(data[,"lambert_y"]),
max(data[,"lambert_y"])))
)
# K inhomogène avec  l'enveloppe
kenv_filiere <- envelope(ppp_filiere, process)
#représentation graphique
plot(kenv_filiere, main= filiere_choice, xlab = "r (mètres)")
}
centroids <- st_centroid(df_fonds_EDMD_for_carto %>% dplyr:: filter(statut_finance_ecolo_dmd==1))
data_for_ppp        <- data.frame(st_coordinates(centroids))
colnames(data_for_ppp)= c("lambert_x", "lambert_y")
data_for_ppp$filiere= "KinEDMD"
repr_ppp(data= data_for_ppp, filiere_choice= "KinEDMD")
library(stars)
raster_planar<-st_rasterize(planar_sf_breizh) #créer un raster à partir de notre objet sf
plot(raster_planar['cp_EDMD', ])
variable <-as.im(raster_planar['cp_EDMD',]) # le raster a plusieurs variables, choisir le cp_EDMD
modele_cp_EDMD<-ppm(ppp_points_breizh~ variable) #Modèle de poisson de notre processus ponctuel expliqué par le fonds_cp_EDMD
modele_cp_EDMD
#plot(effectfun(modele_cp_EDMD, "variable", se.fit = TRUE),legend = FALSE)
plot(predict(modele_cp_EDMD), main = "Prédictions" ,col=col)
# # Résumé Statistiques
# df_fonds_EDMD %>%
#   dplyr::select(-c("code_com","code_dept","code_arr","lib_com","lib_arr","lib_dept")) %>% stargazer( ., type = "text", title="Descriptive statistics", digits=2)
#plot(effectfun(modele_cp_EDMD, "variable", se.fit = TRUE),legend = FALSE)
plot(predict(modele_cp_EDMD), main = "Prédictions" ,col=col)
model_intercept <- ppm(ppp_points_breizh ~ 1)  #Null model
anova(model_intercept, modele_cp_EDMD, test = "LRT") # Compare null to population model
plot(effectfun(modele_cp_EDMD, "variable", se.fit = TRUE),legend = FALSE)
col
col <- colorRampPalette(c("#BB4444", "#EE9988", "beige", "orange", "#77AADD", "#4477AA"))
plot(effectfun(modele_cp_EDMD, "variable", se.fit = TRUE),legend = FALSE)
plot(predict(modele_cp_EDMD), main = "Prédictions" ,col=col)
plot(
pts_eco,
pch = 20, cex= 0.4,  col =  "black",
add = TRUE,
main="Communes bénéficiaires du fonds EDMD")
pts_eco <- st_as_sf(
st_centroid(df_fonds_EDMD_for_carto %>% dplyr:: filter(statut_finance_ecolo_dmd==1)),
coords = c("xcl2154","ycl2154"),
crs    = 2154,
remove = FALSE) %>%
st_transform(2154)
par(mar = c(0, 0, 1, 0))
plot(
st_geometry(bretagne),
col    = "lightgrey",
border = "darkgrey",
main   = ""
)
plot(
pts_eco,
pch = 20, cex= 0.4,  col =  "black",
add = TRUE,
title="Communes bénéficiaires du fonds EDMD")
pts_eco <- st_as_sf(
st_centroid(df_fonds_EDMD_for_carto %>% dplyr:: filter(statut_finance_ecolo_dmd==1)),
coords = c("xcl2154","ycl2154"),
crs    = 2154,
remove = FALSE) %>%
st_transform(2154)
par(mar = c(0, 0, 1, 0))
plot(
st_geometry(bretagne),
col    = "lightgrey",
border = "darkgrey",
main="Communes bénéficiaires du fonds EDMD"
)
plot(
pts_eco,
pch = 20, cex= 0.4,  col =  "black",
add = TRUE)
# Imputation multiple par chaînes de Markov (valeurs plausibles)
imputed_data <- mice(df_fonds_EDMD, method = "rf", m = 5)
df_fonds_EDMD <- complete(imputed_data)
# Imputation multiple par chaînes de Markov (valeurs plausibles)
imputed_data <- mice(df_fonds_EDMD, method = "rf", m = 5)
df_fonds_EDMD <- complete(imputed_data)
# Imputation multiple par chaînes de Markov (valeurs plausibles)
imputed_data <- mice(df_fonds_EDMD, method = "rf", m = 5)
df_fonds_EDMD <- complete(imputed_data)
# Imputation multiple par chaînes de Markov (valeurs plausibles)
imputed_data <- mice(df_fonds_EDMD, method = "rf", m = 5)
df_fonds_EDMD <- complete(imputed_data)
knitr::opts_chunk$set(echo = TRUE)
# 2. Load the conflicted package first to manage masking
library(conflicted)
conflict_prefer("filter", "dplyr")
conflict_prefer("lag",    "dplyr")
conflict_prefer("select", "dplyr")
conflict_prefer("union",    "base")
conflict_prefer("intersect","base")
conflict_prefer("setdiff",  "base")
conflict_prefer("setequal", "base")
conflict_prefer("select", "dplyr")  # keep select
conflict_prefer("area",   "terra")
conflict_prefer("extract", "tidyr")
conflict_prefer("step", "recipes")
conflict_prefer("discard", "scales")
conflict_prefer("spec", "readr")
# 4. Load core libraries
library(dplyr)
library(tidyverse)
library(stargazer)
library(ggplot2)
library(rnaturalearth)
library(sf)
library(viridis)
library(corrplot)
# 5. Load spatial/ecological analysis packages
library(rnaturalearthdata)
library(raster)
library(terra)
library(spatstat)
library(spdep)
# 6. Load modeling and visualization packages
library(factoextra)
library(FactoMineR)
library(umap)
library(tmap)
library(dbscan)
library(mice)
library(leaps)
library(bestglm)
library(tidymodels)
library(caret)
library(patchwork)
library(RColorBrewer)
library(yardstick)
library(vip)
library(tidymodels)
df_fonds_EDMD= read.csv("/home/emiliano/Documents/MASTER_MAS/ALTERNANCE/FONDS VERT/DATA_PRETREATMENT/fonds_vert.csv", sep = ",", dec= ".")
# Création de variable binaire relative à la variable cible
df_fonds_EDMD$statut_finance_ecolo_dmd <- as.numeric(df_fonds_EDMD$cp_EDMD > 0)
# Transformation des colonnes a double modalité en facteur
df_fonds_EDMD <- df_fonds_EDMD %>%
mutate(across(c(gridens7, gare_tgv, ecoquartiers, climat, beneficiaire_prog, statut_finance_ecolo_dmd), as.factor)) %>%
dplyr::select(where(~ n_distinct(.) > 1))
n = dim(df_fonds_EDMD)[1]
p = dim(df_fonds_EDMD)[2]
col_name= c()
total_na= c()
for (j in c(1:p)) {
tot_na= sum(is.na(df_fonds_EDMD[, j]))
if(tot_na > 0){
col_name= c(col_name, colnames(df_fonds_EDMD)[j])
total_na= c(total_na, tot_na)
}
}
data.frame("columns_names"=
col_name,
"Total_na" = total_na)
# Imputation multiple par chaînes de Markov (valeurs plausibles)
imputed_data <- mice(df_fonds_EDMD, method = "rf", m = 5)
df_fonds_EDMD <- complete(imputed_data)
# # Résumé Statistiques
# df_fonds_EDMD %>%
#   dplyr::select(-c("code_com","code_dept","code_arr","lib_com","lib_arr","lib_dept")) %>% stargazer( ., type = "text", title="Descriptive statistics", digits=2)
#summary(df_fonds_EDMD$cp_EDMD)
cible_var= df_fonds_EDMD$cp_EDMD
par(mfrow=c(1,2), las=1)
plot(sort(cible_var), col=rev(terrain.colors(length(cible_var))),ylim=c(0,2e+08), pch=20, cex=.75, ylab='cp_EDMD')
hist(cible_var, main='', col=rev(terrain.colors(5)),  xlim=c(0,4e+08), xlab='cp_EDMD')
# Chargement des données géographiques (communes ou départements)
com <- read_sf("commune_sf")  # ou un autre fichier contenant la géo
# Filtrer uniquement les départements de Bretagne
bretagne <- com %>% dplyr:: filter(reg == "53")
colnames(bretagne)[1] = "code_com"
bretagne$code_com = as.double(bretagne$code_com)
df_fonds_EDMD_for_carto = left_join(df_fonds_EDMD, bretagne, by = "code_com")
df_fonds_EDMD_for_carto <- st_as_sf(df_fonds_EDMD_for_carto)
# Tracer uniquement la Bretagne
ggplot(df_fonds_EDMD_for_carto) +
geom_sf(aes(fill = statut_finance_ecolo_dmd)) +
scale_fill_manual(
values = c("0" = "pink", "1" = "turquoise"),
name = "Statut du bénéficiaire fonds EDMD",
labels = c("Non", "Oui")
) +
#  labs(title = "Répartition des bénéficiaires du fonds écologie \net developpement des mobilitées durables par commune")+
theme_void() +  coord_sf()
# Tracer uniquement la Bretagne
ggplot(df_fonds_EDMD_for_carto) +
geom_sf(aes(fill = cp_EDMD)) +
scale_fill_continuous(low="beige",high= c("green", "red"))+
theme_void() +  coord_sf()
# Tracer uniquement la Bretagne
ggplot(df_fonds_EDMD_for_carto) +
geom_sf(aes(fill = taux_subvention)) +
scale_fill_continuous(low="beige",high="blue")+
theme_void() +  coord_sf()
df_fonds_EDMD %>% dplyr::select(statut_finance_ecolo_dmd) %>%
summary()
library(dplyr)
planar_sf_breizh<-st_transform(df_fonds_EDMD_for_carto , 2154)
centroids_benef <- st_centroid(df_fonds_EDMD_for_carto %>% dplyr::filter(statut_finance_ecolo_dmd==1))
planar_center_com_breizh <-st_transform(centroids_benef, 2154)
ppp_points_breizh <- as.ppp(st_coordinates(planar_center_com_breizh),as.owin(planar_sf_breizh))
ds_breizh <- density(ppp_points_breizh) #sample version
plot(ds_breizh, main= "")
xy <- cbind(x=df_fonds_EDMD$p_pop, y=df_fonds_EDMD$taux_subvention)
plot(xy, cex=cible_var/1e+08, xlim=c(0,25000), ylim=c(0,0.9), col=rev(terrain.colors(50)))
df_fonds_EDMD[df_fonds_EDMD$taux_subvention >0.85,]%>%
dplyr::select(lib_com, taux_subvention, p_pop, superf_choro) %>%
arrange(desc(taux_subvention))
df_fonds_EDMD_for_carto <- st_transform(df_fonds_EDMD_for_carto, crs = 4326)  # reprojection
df_fonds_EDMD_for_carto$cp_EDMD <- as.numeric(df_fonds_EDMD_for_carto$cp_EDMD)
### Récupération des centroides
coor<-st_centroid(st_geometry(df_fonds_EDMD_for_carto))
#Extraction de la liste des voisins (au sens Queen par défaut)
communes_link_queen <- poly2nb(df_fonds_EDMD_for_carto, queen= TRUE)
card_communes_link_queen<-card(communes_link_queen)
tmap_mode("plot")
tm_shape(df_fonds_EDMD_for_carto) +
tm_polygons(col="white", border.col = "blue") +
tm_graticules(lines = FALSE) +
tm_shape(st_centroid(df_fonds_EDMD_for_carto)) +
tm_dots(size = 0.1, col="green") +
tm_shape(nb2lines(communes_link_queen, coords=coor)) +
tm_lines(col="red", lwd=0.3) +
tm_layout(title ="Voisins contigus (Queen)",title.position = c('left', 'bottom'),scale=0.5)
ggplot() +
geom_density(aes(x=card_communes_link_queen)) +
xlab("Nombres de voisins")+ggtitle("Voisins contigus (Queen)")
planar_sf_breizh_KS<-st_transform(df_fonds_EDMD_for_carto , 2154)
centroids_benef_KS <- st_centroid(df_fonds_EDMD_for_carto)
planar_center_com_breizh_KS <-st_transform(centroids_benef, 2154)
ppp_points_breizh_KS <- as.ppp(st_coordinates(planar_center_com_breizh),
as.owin(planar_sf_breizh))
ds_breizh_KS <- density(ppp_points_breizh)
####################################################################
centroids_benef_ponct <- st_centroid(df_fonds_EDMD_for_carto %>%
dplyr::filter(statut_finance_ecolo_dmd==1))
planar_center_com_breizh_ponct <-st_transform(centroids_benef, 2154)
planar_sf_breizh_KS_ponct<-st_transform(df_fonds_EDMD_for_carto %>%
dplyr::filter(statut_finance_ecolo_dmd==1),
2154)
ppp_points_breizh_KS_ponct <- as.ppp(st_coordinates(planar_center_com_breizh_ponct),
as.owin(planar_sf_breizh_KS_ponct))
KS.test <- cdf.test(ppp_points_breizh_KS_ponct, ds_breizh_KS, test="ks")
KS.test
pts_eco <- st_as_sf(
st_centroid(df_fonds_EDMD_for_carto %>% dplyr:: filter(statut_finance_ecolo_dmd==1)),
coords = c("xcl2154","ycl2154"),
crs    = 2154,
remove = FALSE) %>%
st_transform(2154)
par(mar = c(0, 0, 1, 0))
plot(
st_geometry(bretagne),
col    = "lightgrey",
border = "darkgrey",
main="Communes bénéficiaires du fonds EDMD"
)
plot(
pts_eco,
pch = 20, cex= 0.4,  col =  "black",
add = TRUE)
# Représentation du diagramme de Moran
#Création de la matrice de poids standardisé en ligne = méthode par défaut
W_Queen <- nb2listw(communes_link_queen ,zero.policy=TRUE,style="W")
m1 <- listw2mat(W_Queen)
#Calcul des fonds écologie et developpement durable standardisés
df_fonds_EDMD_for_carto$cp_EDMD_std <- as.vector(scale(df_fonds_EDMD_for_carto$cp_EDMD))
# Représentation cartographique du diagramme de Moran
#revenu médian des voisins (Wy)
df_fonds_EDMD_for_carto$v_cp_EDMD_std<-lag.listw(W_Queen,df_fonds_EDMD_for_carto$cp_EDMD_std)
#Variable indicatrice (high high, low low ect)
df_fonds_EDMD_for_carto$hs[df_fonds_EDMD_for_carto$v_cp_EDMD_std<mean(df_fonds_EDMD_for_carto$cp_EDMD_std) & df_fonds_EDMD_for_carto$cp_EDMD_std<mean(df_fonds_EDMD_for_carto$cp_EDMD_std)]<-1.0
df_fonds_EDMD_for_carto$hs[df_fonds_EDMD_for_carto$v_cp_EDMD_std>=mean(df_fonds_EDMD_for_carto$cp_EDMD_std) & df_fonds_EDMD_for_carto$cp_EDMD_std<mean(df_fonds_EDMD_for_carto$cp_EDMD_std)]<-2.0
df_fonds_EDMD_for_carto$hs[df_fonds_EDMD_for_carto$v_cp_EDMD_std<mean(df_fonds_EDMD_for_carto$cp_EDMD_std) & df_fonds_EDMD_for_carto$cp_EDMD_std>=mean(df_fonds_EDMD_for_carto$cp_EDMD_std)]<-3.0
df_fonds_EDMD_for_carto$hs[df_fonds_EDMD_for_carto$v_cp_EDMD_std>=mean(df_fonds_EDMD_for_carto$cp_EDMD_std) & df_fonds_EDMD_for_carto$cp_EDMD_std>=mean(df_fonds_EDMD_for_carto$cp_EDMD_std)]<-4.0
brks <- c(1,2,3,4)
colors <- rev(brewer.pal(n = 4, name = "RdYlBu"))
#diagramme de Moran
# args(moran.plot)
par(mfrow= c(1,2))
par(mar = c(0, 0, 1, 0))
moran.plot(df_fonds_EDMD_for_carto$cp_EDMD_std ,
W_Queen,labels=TRUE, pch = ".",
xlab="Fonds écologie et développement durable",ylab="Moyenne des fonds écologie et développement durable")
par(mar = c(0, 0, 1, 0))
plot(st_geometry(df_fonds_EDMD_for_carto),border="lightgray",col=colors[findInterval(df_fonds_EDMD_for_carto$hs,brks,all.inside=FALSE)]
#, main= "Cartographie du diagramme de Moran"
)
legend("bottomleft", legend = c('BB','BH','HB','HH'),
fill=colors,bty="n")
moran.test(df_fonds_EDMD_for_carto$cp_EDMD_std,W_Queen,zero.policy=TRUE, randomisation=FALSE)
moran.test(df_fonds_EDMD_for_carto$cp_EDMD_std, W_Queen,zero.policy=TRUE, randomisation=TRUE)
library(spdep)
# Autocorélation local
lisa_cp_EDMD<- localmoran(df_fonds_EDMD_for_carto$cp_EDMD,W_Queen,zero.policy=TRUE)
local_moran <- localmoran(df_fonds_EDMD_for_carto$cp_EDMD_std, W_Queen, zero.policy = TRUE)
pval <- local_moran[, "Pr(z != E(Ii))"]
# significance threshold
signif <- 0.05
var_std<-df_fonds_EDMD_for_carto$cp_EDMD_std
# centers the local Moran's around the mean
local<-lisa_cp_EDMD[,1]-mean(lisa_cp_EDMD[,1])
# Construction d’un data.frame pour le scatterplot
moran_df <- data.frame(
var_std = var_std,
local = local,
pval = pval
)
# Typologie selon quadrants
moran_df <- moran_df %>%
mutate(cadrant = case_when(
var_std > 0 & local > 0 & pval <= signif ~ "haut-haut",
var_std < 0 & local < 0 & pval <= signif ~ "bas-bas",
var_std > 0 & local < 0 & pval <= signif ~ "haut-bas",
var_std < 0 & local > 0 & pval <= signif ~ "bas-haut",
TRUE ~ "Non significatif"
),
brks = case_when(
var_std > 0 & local > 0 & pval <= signif ~ 4,
var_std < 0 & local < 0 & pval <= signif ~ 1,
var_std > 0 & local < 0 & pval <= signif ~ 3,
var_std < 0 & local > 0 & pval <= signif ~ 2,
TRUE ~ 0
),
colors = case_when(
var_std > 0 & local > 0 & pval <= signif ~ "red",
var_std < 0 & local < 0 & pval <= signif ~ "blue",
var_std > 0 & local < 0 & pval <= signif ~ "orange",
var_std < 0 & local > 0 & pval <= signif ~ "lightblue",
TRUE ~ "lightgray"
))
par(mfrow= c(1,2))
par(mar = c(0, 0, 1, 0))
# Créer le plot de base
plot(
moran_df$var_std, moran_df$local,
col = moran_df$colors,
pch = 19,
xlab = "Valeur standardisée des cp_EDMD",
ylab = "Moyenne pondérée des voisins",
main = ""
)
# Lignes horizontale et verticale
abline(h = 0, lty = 2, col = "black")
abline(v = 0, lty = 2, col = "black")
## carte I Moran locaux
# quadrant <- vector(mode="numeric",length=nrow(lisa_cp_EDMD))
#
# # builds a data quadrant
# quadrant[var_std>0 & local>0  & lisa_cp_EDMD[,5] < signif] <- 4
# quadrant[var_std <0 & local<0 & lisa_cp_EDMD[,5] < signif] <- 1
# quadrant[var_std <0 & local>0 & lisa_cp_EDMD[,5] < signif] <- 2
# quadrant[var_std >0 & local<0 & lisa_cp_EDMD[,5] < signif] <- 3
# quadrant[lisa_cp_EDMD[,5]>signif] <- 0
#
# # plot in r
# brks <- c(0,1,2,3,4)
colors_leg <- c("lightgray","blue","lightblue","orange","red")
par(mar = c(0, 0, 1, 0))
plot(st_geometry(df_fonds_EDMD_for_carto),border="white",col=moran_df$colors)
legend("bottomleft", legend = c("non significatif","bas-bas","bas-haut","haut-bas","haut-haut"),
fill= colors_leg,bty="n")
# Calcul de la densité
dens <- density(lisa_cp_EDMD[, 1])
# Tracé de la courbe
plot(dens,
main    = "",
xlab    = "Indices de Moran local (LISA)",
ylab    = "Densité",
lwd     = 2
)
# Ajout du trait vertical rouge à x = 0.08
abline(v = 0.08, col = "red", lwd = 2)
# Ajout du texte pour indiquer que c'est le I de Moran global
text(x = 0.08,
y = max(dens$y) * 0.9,
labels = "I de Moran global",
pos = 4,
col = "red")
repr_ppp= function(data, filiere_choice, process= Kest){
data= data %>% filter(filiere== filiere_choice)
#Création d’un point pattern ppp= representing a point pattern dataset in the two-dimensional plane, avec owin la zone d’étude
ppp_filiere <- as.ppp(data[ ,c ("lambert_x", "lambert_y")],
owin(c(min(data[,"lambert_x"]),
max(data[,"lambert_x"])),
c(min(data[,"lambert_y"]),
max(data[,"lambert_y"])))
)
# K inhomogène avec  l'enveloppe
kenv_filiere <- envelope(ppp_filiere, process)
#représentation graphique
plot(kenv_filiere, main= filiere_choice, xlab = "r (mètres)")
}
centroids <- st_centroid(df_fonds_EDMD_for_carto %>% dplyr:: filter(statut_finance_ecolo_dmd==1))
data_for_ppp        <- data.frame(st_coordinates(centroids))
colnames(data_for_ppp)= c("lambert_x", "lambert_y")
data_for_ppp$filiere= "KinEDMD"
repr_ppp(data= data_for_ppp, filiere_choice= "KinEDMD")
library(stars)
raster_planar<-st_rasterize(planar_sf_breizh) #créer un raster à partir de notre objet sf
plot(raster_planar['cp_EDMD', ])
variable <-as.im(raster_planar['cp_EDMD',]) # le raster a plusieurs variables, choisir le cp_EDMD
modele_cp_EDMD<-ppm(ppp_points_breizh~ variable) #Modèle de poisson de notre processus ponctuel expliqué par le fonds_cp_EDMD
modele_cp_EDMD
col <- colorRampPalette(c("#BB4444", "#EE9988", "beige", "orange", "#77AADD", "#4477AA"))
plot(effectfun(modele_cp_EDMD, "variable", se.fit = TRUE),legend = FALSE)
plot(predict(modele_cp_EDMD), main = "Prédictions" ,col=col)
model_intercept <- ppm(ppp_points_breizh ~ 1)  #Null model
anova(model_intercept, modele_cp_EDMD, test = "LRT") # Compare null to population model
