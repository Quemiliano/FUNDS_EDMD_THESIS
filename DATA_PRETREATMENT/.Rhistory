palette = "jco",
title = "ACP des données iris")
# Visualisation avec les individus colorés selon l'espèce
fviz_pca_ind(acp,
habillage = df_fonds_vert_for_stat_desc$benef_trans_eco,
addEllipses = TRUE,
label = "none",
palette = "jco",
title = "ACP des données iris")
library(factoextra)
# Réaliser l'ACP
acp <- prcomp(df_clean_for_PCA[,c(1:40)], scale. = TRUE)
summary(df_clean_for_PCA$eolienne_prod_therm_kw)
# Visualisation avec les individus colorés selon l'espèce
fviz_pca_ind(acp,
habillage = df_fonds_vert_for_stat_desc$benef_trans_eco,
addEllipses = TRUE,
label = "none",
palette = "jco",
title = "ACP des données iris")
sum(df_clean_for_PCA)
(df_clean_for_PCA).sum()
sum(df_clean_for_PCA, axis= 1)
sum(df_clean_for_PCA, axis= 2)
sum(df_clean_for_PCA, axis= 0)
sum(df_clean_for_PCA, axis= 0)
library(factoextra)
# Réaliser l'ACP
df_clean_for_PCA <- df_clean_for_PCA[, colSums(df_clean_for_PCA, na.rm = TRUE) > 0]
acp <- prcomp(df_clean_for_PCA, scale. = TRUE)
# Visualisation avec les individus colorés selon l'espèce
fviz_pca_ind(acp,
habillage = df_fonds_vert_for_stat_desc$benef_trans_eco,
addEllipses = TRUE,
label = "none",
palette = "jco",
title = "ACP des données iris")
library(factoextra)
# Réaliser l'ACP
df_clean_for_PCA <- df_clean_for_PCA[, colSums(df_clean_for_PCA, na.rm = TRUE) > 0]
acp <- prcomp(df_clean_for_PCA, scale. = TRUE)
# Visualisation avec les individus colorés selon l'espèce
fviz_pca_ind(acp,
addEllipses = TRUE,
label = "none",
palette = "jco",
title = "ACP des données iris")
library(factoextra)
# Réaliser l'ACP
dim(df_clean_for_PCA)
df_clean_for_PCA <- df_clean_for_PCA[, colSums(df_clean_for_PCA, na.rm = TRUE) > 0]
dim(df_clean_for_PCA)
acp <- prcomp(df_clean_for_PCA, scale. = TRUE)
# Visualisation avec les individus colorés selon l'espèce
fviz_pca_ind(acp,
habillage = df_fonds_vert_for_stat_desc$benef_trans_eco,
addEllipses = TRUE,
label = "none",
palette = "jco",
title = "ACP des données iris")
library(FactoMineR)
library(factoextra)
library(dplyr)
# Nettoyage des données
df_clean <- na.omit(df_fonds_vert_for_stat_desc)
# Conversion des colonnes en numérique
df_clean_for_PCA <- df_clean %>%
mutate(across(c(gridens7, gare_tgv, ecoquartiers, climat, beneficiaire_prog, benef_trans_eco,
benef_admin_generale_terri, benef_solidar_insertion_egal_chance, benef_economie,
benef_direction_action_gouv, benef_culture, benef_relation_collectivite_loc,
benef_rembourse_degreve, benef_securite, benef_justice, benef_travail_emploi,
benef_media_livre_indus_culture, benef_ecologie_dev_mob_durable,
benef_immigration_asile_integr, benef_sport_jeune_assos,
benef_recherche_ens_sup, benef_ens_scolaire, benef_plan_relance,
benef_aide_publiq_dev, benef_cohes_terri, benef_ges_finance_publiq,
benef_transfo_fonct_publiq, benef_agri_alim_foret_aff_rurale), as.numeric))
# Analyse en composantes principales
acp <- PCA(df_clean_for_PCA, graph = FALSE)
# Extraire les contributions
var_contrib <- acp$var$contrib
library(factoextra)
# Réaliser l'ACP
dim(df_clean_for_PCA)
df_clean_for_PCA <- df_clean_for_PCA[, colSums(df_clean_for_PCA, na.rm = TRUE) > 0]
dim(df_clean_for_PCA)
acp <- prcomp(df_clean_for_PCA, scale. = TRUE)
# Visualisation avec les individus colorés selon l'espèce
fviz_pca_ind(acp,
habillage = df_fonds_vert_for_stat_desc$benef_trans_eco,
addEllipses = TRUE,
label = "none",
palette = "jco",
title = "ACP des données iris")
reticulate::repl_python()
library(factoextra)
# Réaliser l'ACP
df_clean_for_PCA <- df_clean_for_PCA[, colSums(df_clean_for_PCA, na.rm = TRUE) > 0]
acp <- prcomp(df_clean_for_PCA, scale. = TRUE)
# Visualisation avec les individus colorés selon l'espèce
fviz_pca_ind(acp,
habillage = df_fonds_vert_for_stat_desc$benef_trans_eco,
addEllipses = TRUE,
label = "none",
palette = "jco",
title = "ACP des données iris")
library(factoextra)
# Réaliser l'ACP
df_clean_for_PCA <- df_clean_for_PCA[, colSums(df_clean_for_PCA, na.rm = TRUE) > 0]
acp <- prcomp(df_clean_for_PCA, scale. = TRUE)
# Visualisation avec les individus colorés selon l'espèce
fviz_pca_ind(acp,
habillage = df_clean_for_PCA$benef_trans_eco,
addEllipses = TRUE,
label = "none",
palette = "jco",
title = "ACP des données iris")
library(factoextra)
# Réaliser l'ACP
df_clean_for_PCA <- df_clean_for_PCA[, colSums(df_clean_for_PCA, na.rm = TRUE) > 0]
acp <- prcomp(df_clean_for_PCA, scale. = TRUE)
# Visualisation avec les individus colorés selon l'espèce
fviz_pca_ind(acp,
habillage = df_clean_for_PCA$benef_trans_eco,
addEllipses = TRUE,
label = "0",
palette = "jco",
title = "ACP des données iris")
# Graphique combiné
fviz_pca_biplot(acp,
label= "none",
repel = TRUE,           # Répulsion des labels
col.var = "contrib",    # Couleurs des variables selon leur contribution
gradient.cols = c("blue", "yellow", "red"),
col.ind = "black")      # Couleur des individus
# Graphique combiné
fviz_pca_biplot(acp,
label= "none",
repel = TRUE,           # Répulsion des labels
col.var = "contrib",
col.ind = "black")      # Couleur des individus
# Graphique combiné
fviz_pca_biplot(acp,
label= "none",
repel = F,           # Répulsion des labels
col.var = "contrib",
col.ind = "black")      # Couleur des individus
# Graphique combiné
fviz_pca_biplot(acp,
col.ind = "black")      # Couleur des individus
# Graphique combiné
fviz_pca_biplot(acp)      # Couleur des individus
# Graphique combiné
fviz_pca_biplot(acp,
label= "none",
repel = TRUE,           # Répulsion des labels
col.var = "contrib",    # Couleurs des variables selon leur contribution
gradient.cols = c("blue", "yellow", "red"),
col.ind = "black")      # Couleur des individus
# Étape 1 : Nettoyage (comme avant)
df_clean <- na.omit(df_fonds_vert_for_stat_desc)
df_numeric <- df_clean[, sapply(df_clean, is.numeric)]
# Garde aussi la colonne "region" comme regroupement
group_var <- df_clean$benef_trans_eco
# Supprimer NA / Inf
df_numeric <- df_numeric[complete.cases(df_numeric), ]
group_var <- group_var[complete.cases(df_numeric)]  # suivre la même suppression
df_numeric <- df_numeric[apply(df_numeric, 1, function(row) all(is.finite(row))), ]
group_var <- group_var[apply(df_numeric, 1, function(row) all(is.finite(row)))]
# Supprimer colonnes à variance nulle
df_numeric <- df_numeric[, apply(df_numeric, 2, function(col) sd(col, na.rm = TRUE) > 0)]
# Standardisation
df_scaled <- scale(df_numeric)
# Supprimer doublons
dedup_index <- !duplicated(df_scaled)
df_scaled_unique <- df_scaled[dedup_index, ]
group_var_unique <- group_var[dedup_index]
# UMAP
umap_result <- umap(df_scaled_unique)
# Création du data frame pour ggplot
umap_df <- data.frame(
X = umap_result$layout[, 1],
Y = umap_result$layout[, 2],
Groupe = as.factor(group_var_unique)  # La variable de regroupement
)
# Visualisation colorée par groupe
ggplot(umap_df, aes(x = X, y = Y, color = Groupe)) +
geom_point(alpha = 0.7, size = 3) +
ggtitle("Projection UMAP avec couleur par statut de demande") +
theme_minimal() +
theme(legend.position = "bottom")
regression.1= lm(benef_trans_eco ~ ., data= df_clean_for_PCA)
#stargazer(regression.1,   title="Modèles de régression linéaire",align=TRUE, type="text", digits=3)
summary(regression.1)
full.model <- lm(benef_trans_eco ~ ., data= df_clean_for_PCA) # estimation du modèle complet
regression <- stepAIC(full.model,direction = "backward",  trace = FALSE) # Backward regression model
library(MASS)
full.model <- lm(benef_trans_eco ~ ., data= df_clean_for_PCA) # estimation du modèle complet
regression <- stepAIC(full.model,direction = "backward",  trace = FALSE) # Backward regression model
library(MASS)
full.model <- lm(benef_trans_eco ~ ., data= df_clean_for_PCA) # estimation du modèle complet
regression <- stepAIC(full.model,direction = "backward",  trace = FALSE) # Backward regression model
stargazer(regression)
stargazer(regression, digit= 2)
stargazer(regression, digit= 3)
stargazer(regression, digits= 3)
stargazer(regression, digits= 1)
stargazer(regression, digit= 1)
summary(regression)
library(MASS)
full.model <- glm(benef_trans_eco ~ ., data = df_clean_for_PCA, family = binomial)
full.model <- glm(benef_trans_eco ~ ., data = df_clean_for_PCA, family = binomial)
class(df_clean_for_PCA$benef_trans_eco)
library(MASS)
full.model <- glm(benef_trans_eco ~ ., data = df_fonds_vert_for_stat_desc, family = binomial)
# estimation du modèle complet
regression <- stepAIC(full.model,direction = "backward",  trace = FALSE) # Backward regression model
library(MASS)
full.model <- glm(benef_trans_eco ~ ., data = df_fonds_vert_for_stat_desc, family = binomial) # estimation du modèle complet
regression.log <- stepAIC(full.model,direction = "backward",  trace = FALSE) # Backward regression model
reticulate::repl_python()
#install.packages("rnaturalearthdata")
library(dplyr)
library(tidyverse)
library(stargazer)
library(ggplot2)
library(sf)
library(viridis)
library(corrplot)
library(umap)
library(ggplot2)
library(umap)
library(dbscan)
df_fonds_vert= read.csv("fonds_vert.csv", sep = ",", dec= ".")
# Typage de la variable taux de creation CHAR---> INT
# Transformation des colonnes a double modalité en facteur
df_fonds_vert <- df_fonds_vert %>%
mutate(across(c(gridens7, gare_tgv, ecoquartiers, climat, beneficiaire_prog, benef_trans_eco, benef_admin_generale_terri, benef_solidar_insertion_egal_chance, benef_economie, benef_direction_action_gouv, benef_culture, benef_relation_collectivite_loc, benef_rembourse_degreve, benef_securite, benef_justice, benef_travail_emploi,  benef_media_livre_indus_culture, benef_ecologie_dev_mob_durable, benef_immigration_asile_integr, benef_sport_jeune_assos, benef_recherche_ens_sup, benef_ens_scolaire, benef_ens_scolaire, benef_plan_relance, benef_aide_publiq_dev, benef_cohes_terri, benef_ges_finance_publiq, benef_transfo_fonct_publiq, benef_agri_alim_foret_aff_rurale), as.factor))
# Suppression des colonnes non impliqué dans la stat desc
df_fonds_vert_for_stat_desc = df_fonds_vert %>%
select(-c("code_com","code_reg","code_dept","code_arr","lib_com","lib_arr","lib_dept","lib_reg"))
df_fonds_vert= read.csv("fonds_vert.csv", sep = ",", dec= ".")
# Typage de la variable taux de creation CHAR---> INT
# Transformation des colonnes a double modalité en facteur
df_fonds_vert <- df_fonds_vert %>%
mutate(across(c(gridens7, gare_tgv, ecoquartiers, climat, beneficiaire_prog, benef_trans_eco, benef_admin_generale_terri, benef_solidar_insertion_egal_chance, benef_economie, benef_direction_action_gouv, benef_culture, benef_relation_collectivite_loc, benef_rembourse_degreve, benef_securite, benef_justice, benef_travail_emploi,  benef_media_livre_indus_culture, benef_ecologie_dev_mob_durable, benef_immigration_asile_integr, benef_sport_jeune_assos, benef_recherche_ens_sup, benef_ens_scolaire, benef_ens_scolaire, benef_plan_relance, benef_aide_publiq_dev, benef_cohes_terri, benef_ges_finance_publiq, benef_transfo_fonct_publiq, benef_agri_alim_foret_aff_rurale), as.factor))
# Suppression des colonnes non impliqué dans la stat desc
df_fonds_vert_for_stat_desc = df_fonds_vert %>%
select(-c("code_com","code_reg","code_dept","code_arr","lib_com","lib_arr","lib_dept","lib_reg"))
df_fonds_vert_for_stat_desc = df_fonds_vert %>%
select(-c("code_com","code_reg","code_dept","code_arr","lib_com","lib_arr","lib_dept","lib_reg"))
#install.packages("rnaturalearthdata")
library(dplyr)
library(tidyverse)
library(stargazer)
library(ggplot2)
library(sf)
library(viridis)
library(corrplot)
library(umap)
library(ggplot2)
library(umap)
library(dbscan)
df_fonds_vert= read.csv("fonds_vert.csv", sep = ",", dec= ".")
# Typage de la variable taux de creation CHAR---> INT
# Transformation des colonnes a double modalité en facteur
df_fonds_vert <- df_fonds_vert %>%
mutate(across(c(gridens7, gare_tgv, ecoquartiers, climat, beneficiaire_prog, benef_trans_eco, benef_admin_generale_terri, benef_solidar_insertion_egal_chance, benef_economie, benef_direction_action_gouv, benef_culture, benef_relation_collectivite_loc, benef_rembourse_degreve, benef_securite, benef_justice, benef_travail_emploi,  benef_media_livre_indus_culture, benef_ecologie_dev_mob_durable, benef_immigration_asile_integr, benef_sport_jeune_assos, benef_recherche_ens_sup, benef_ens_scolaire, benef_ens_scolaire, benef_plan_relance, benef_aide_publiq_dev, benef_cohes_terri, benef_ges_finance_publiq, benef_transfo_fonct_publiq, benef_agri_alim_foret_aff_rurale), as.factor))
# Suppression des colonnes non impliqué dans la stat desc
df_fonds_vert_for_stat_desc = df_fonds_vert %>%
select(-c("code_com","code_reg","code_dept","code_arr","lib_com","lib_arr","lib_dept","lib_reg"))
df_fonds_vert_for_stat_desc
df_fonds_vert
df_fonds_vert_for_stat_desc = df_fonds_vert %>%
select(-c("code_com","code_reg","code_dept","code_arr","lib_com","lib_arr","lib_dept","lib_reg"))
df_fonds_vert %>%
select(-c("code_com","code_reg","code_dept","code_arr","lib_com","lib_arr","lib_dept","lib_reg"))
df_fonds_vert_for_stat_desc = df_fonds_vert %>%
dplyr::select(-c("code_com","code_reg","code_dept","code_arr","lib_com","lib_arr","lib_dept","lib_reg"))
df_fonds_vert_for_stat_desc
df_fonds_vert= read.csv("fonds_vert.csv", sep = ",", dec= ".")
# Typage de la variable taux de creation CHAR---> INT
# Transformation des colonnes a double modalité en facteur
df_fonds_vert <- df_fonds_vert %>%
mutate(across(c(gridens7, gare_tgv, ecoquartiers, climat, beneficiaire_prog, benef_trans_eco, benef_admin_generale_terri, benef_solidar_insertion_egal_chance, benef_economie, benef_direction_action_gouv, benef_culture, benef_relation_collectivite_loc, benef_rembourse_degreve, benef_securite, benef_justice, benef_travail_emploi,  benef_media_livre_indus_culture, benef_ecologie_dev_mob_durable, benef_immigration_asile_integr, benef_sport_jeune_assos, benef_recherche_ens_sup, benef_ens_scolaire, benef_ens_scolaire, benef_plan_relance, benef_aide_publiq_dev, benef_cohes_terri, benef_ges_finance_publiq, benef_transfo_fonct_publiq, benef_agri_alim_foret_aff_rurale), as.factor))
# Suppression des colonnes non impliqué dans la stat desc
df_fonds_vert_for_stat_desc = df_fonds_vert %>%
dplyr::select(-c("code_com","code_reg","code_dept","code_arr","lib_com","lib_arr","lib_dept","lib_reg"))
# Présentation du résumé statistique
stargazer(df_fonds_vert_for_stat_desc, type = "text", title="Descriptive statistics", digits=2)
# Chargement des données géographiques (communes ou départements)
dpt <- read_sf("com")  # ou un autre fichier contenant la géo
# Filtrer uniquement les départements de Bretagne
bretagne <- dpt %>% dplyr:: filter(reg == "53")
colnames(bretagne)[1] = "code_com"
bretagne$code_com = as.double(bretagne$code_com)
df_fonds_vert_for_carto = left_join(df_fonds_vert, bretagne, by = "code_com")
df_fonds_vert_for_carto <- st_as_sf(df_fonds_vert_for_carto)
# Tracer uniquement la Bretagne
ggplot(df_fonds_vert_for_carto) +
geom_sf(aes(fill = benef_trans_eco)) +
scale_fill_manual(
values = c("0" = "red", "1" = "green"),
name = "Bénéficiaire\ntransition éco",
labels = c("Non", "Oui")
) +
theme_void() +  coord_sf()
plot_boxplot <- function(data, variable, title, custom_colors, del_atypique = FALSE) {
# Si del_atypique est TRUE, suppression des valeurs atypiques
if (del_atypique) {
# Récupération de la variable en tant que vecteur
var_values <- data[[variable]]
# Identification des valeurs atypiques via la méthode des boxplots
outliers <- boxplot.stats(var_values)$out
# Création d'un dataframe filtré (sans les lignes contenant des valeurs atypiques)
data <- data[!(var_values %in% outliers), ]
}
# Création du boxplot
ggplot(data, aes(x = benef_trans_eco, y = .data[[variable]], fill = benef_trans_eco)) +
geom_boxplot(outlier.color = "red") +
scale_fill_manual(values = custom_colors) +
theme_minimal() +
theme(
legend.position = "none",
plot.title = element_text(size = 10)
) +
ggtitle(title) +
xlab("")
}
ggplot(df_fonds_vert_for_carto) + geom_sf(aes(fill=superf_choro)) +
scale_fill_continuous(low="yellow",high="red")+
theme_void()
# Superficie de la commune
plot_boxplot(
data = df_fonds_vert,
variable = "superf_choro",
title = "Figure : Boxplot de la superficie des communes selon leur statut vis-à-vis du fonds vert",
custom_colors = c("#FF9999", "#66B2FF"), del_atypique= F
)
df_fonds_vert %>%
select(gridens7, benef_trans_eco) %>% table()
df_fonds_vert %>%
dplyr::select(gridens7, benef_trans_eco) %>% table()
ggplot(df_fonds_vert_for_carto) + geom_sf(aes(fill=p_pop)) +
scale_fill_continuous(low="beige",high="red")+
theme_void()
# Population de la commune avec suppression des individus atypiques
plot_boxplot(
data = df_fonds_vert,
variable = "p_pop",
title = "Figure : Boxplot de la population des communes selon leur statut vis-à-vis du fonds vert",
custom_colors = c("#FF9999", "#66B2FF"), del_atypique= T
)
# Nombre d'actes France Renov avec suppression des individus atypiques
plot_boxplot(
data = df_fonds_vert,
variable = "nb_actes_france_renov",
title = "Figure : Boxplot des actes France renov selon leur statut vis-à-vis du fonds vert",
custom_colors = c("#FF9999", "#66B2FF"), del_atypique= T
)
library(FactoMineR)
library(factoextra)
library(dplyr)
# Nettoyage des données
df_clean_fonds_vert <- na.omit(df_fonds_vert_for_stat_desc)
# Conversion des colonnes en numérique
df_clean_fonds_vert_for_PCA <- df_clean_fonds_vert %>%
mutate(across(c(gridens7, gare_tgv, ecoquartiers, climat, beneficiaire_prog, benef_trans_eco,
benef_admin_generale_terri, benef_solidar_insertion_egal_chance, benef_economie,
benef_direction_action_gouv, benef_culture, benef_relation_collectivite_loc,
benef_rembourse_degreve, benef_securite, benef_justice, benef_travail_emploi,
benef_media_livre_indus_culture, benef_ecologie_dev_mob_durable,
benef_immigration_asile_integr, benef_sport_jeune_assos,
benef_recherche_ens_sup, benef_ens_scolaire, benef_plan_relance,
benef_aide_publiq_dev, benef_cohes_terri, benef_ges_finance_publiq,
benef_transfo_fonct_publiq, benef_agri_alim_foret_aff_rurale), as.numeric))
# Analyse en composantes principales
acp <- PCA(df_clean_fonds_vert_for_PCA, graph = FALSE)
# Extraire les contributions
var_contrib <- acp$var$contrib
# Sélectionner les variables ayant une contribution < 0.5 sur le plan (axe 1 et 2)
selected_vars <- which(rowSums(var_contrib[, 1:2]) <= 2)
# Visualiser uniquement ces variables
fviz_pca_var(acp,
axes = c(1, 2),
select.var = list(name = rownames(var_contrib)[selected_vars]),
col.var = "contrib",
gradient.cols = c("blue", "yellow", "red"),
repel = TRUE)
# Sélectionner les variables ayant une contribution < 0.5 sur le plan (axe 1 et 2)
selected_vars <- which(rowSums(var_contrib[, 1:2]) < 2.5 & rowSums(var_contrib[, 1:2]) >= 2 )
# Visualiser uniquement ces variables
fviz_pca_var(acp,
axes = c(1, 2),
select.var = list(name = rownames(var_contrib)[selected_vars]),
col.var = "contrib",
gradient.cols = c("blue", "yellow", "red"),
repel = TRUE)
# Sélectionner les variables ayant une contribution < 0.5 sur le plan (axe 1 et 2)
selected_vars <- which( rowSums(var_contrib[, 1:2]) >= 2.5 & rowSums(var_contrib[, 1:2]) < 3  )
# Visualiser uniquement ces variables
fviz_pca_var(acp,
axes = c(1, 2),
select.var = list(name = rownames(var_contrib)[selected_vars]),
col.var = "contrib",
gradient.cols = c("blue", "yellow", "red"),
repel = TRUE)
# Sélectionner les variables ayant une contribution >= 1.5 sur le plan (axe 1 et 2)
selected_vars <- which(rowSums(var_contrib[, 1:2]) >= 3)
# Visualiser uniquement ces variables
fviz_pca_var(acp,
axes = c(1, 2),
select.var = list(name = rownames(var_contrib)[selected_vars]),
col.var = "contrib",
gradient.cols = c("blue", "yellow", "red"),
repel = TRUE)
library(factoextra)
# Réaliser l'ACP
df_clean_fonds_vert_for_PCA <- df_clean_fonds_vert_for_PCA[, colSums(df_clean_fonds_vert_for_PCA, na.rm = TRUE) > 0]
acp <- prcomp(df_clean_fonds_vert_for_PCA, scale. = TRUE)
# Visualisation avec les individus colorés selon l'espèce
fviz_pca_ind(acp,
habillage = df_clean_fonds_vert_for_PCA$benef_trans_eco,
addEllipses = TRUE,
label = "none",
palette = "jco",
title = "ACP des données à l'échelle des individus")
# Graphique combiné
fviz_pca_biplot(acp,
label= "none",
repel = TRUE,           # Répulsion des labels
col.var = "contrib",    # Couleurs des variables selon leur contribution
gradient.cols = c("blue", "yellow", "red"),
col.ind = "black")      # Couleur des individus
# Garder uniquement les colonnes numériques
df_numeric <- df_clean_fonds_vert[, sapply(df_clean_fonds_vert, is.numeric)]
# Supprimer lignes avec NA ou Inf
df_numeric <- df_numeric[complete.cases(df_numeric), ]
df_numeric <- df_numeric[apply(df_numeric, 1, function(row) all(is.finite(row))), ]
# Supprimer colonnes à variance nulle (problème pour scale())
df_numeric <- df_numeric[, apply(df_numeric, 2, function(col) sd(col, na.rm = TRUE) > 0)]
# Standardisation
df_scaled <- scale(df_numeric)
# Supprimer les doublons
df_scaled_unique <- df_scaled[!duplicated(df_scaled), ]
# UMAP
umap_result <- umap(df_scaled_unique)
# Affichage
umap_df <- data.frame(X = umap_result$layout[,1], Y = umap_result$layout[,2])
ggplot(umap_df, aes(X, Y)) +
geom_point(color = "forestgreen", alpha = 0.6) +
ggtitle("Projection UMAP") +
theme_minimal()
umap_df <- data.frame(X = umap_result$layout[,1], Y = umap_result$layout[,2])
# HDBSCAN (minPts = minimum nombre de points pour former un cluster)
hdb_result <- hdbscan(umap_df, minPts = 33)
# Ajouter les clusters au DataFrame
umap_df$Cluster <- as.factor(hdb_result$cluster)  # 0 = bruit
ggplot(umap_df, aes(X, Y, color = Cluster)) +
geom_point(size = 2, alpha = 0.8) +
scale_color_manual(values = c("0" = "gray","1"= "blue","2"= "red")) +
ggtitle("Projection UMAP + HDBSCAN Clustering") +
theme_minimal()
summary(umap_df)
# Étape 1 : Nettoyage (comme avant)
df_clean_fonds_vert <- na.omit(df_fonds_vert_for_stat_desc)
df_numeric <- df_clean_fonds_vert[, sapply(df_clean_fonds_vert, is.numeric)]
# Garde aussi la colonne "region" comme regroupement
group_var <- df_clean_fonds_vert$benef_trans_eco
# Supprimer NA / Inf
df_numeric <- df_numeric[complete.cases(df_numeric), ]
group_var <- group_var[complete.cases(df_numeric)]  # suivre la même suppression
df_numeric <- df_numeric[apply(df_numeric, 1, function(row) all(is.finite(row))), ]
group_var <- group_var[apply(df_numeric, 1, function(row) all(is.finite(row)))]
# Supprimer colonnes à variance nulle
df_numeric <- df_numeric[, apply(df_numeric, 2, function(col) sd(col, na.rm = TRUE) > 0)]
# Standardisation
df_scaled <- scale(df_numeric)
# Supprimer doublons
dedup_index <- !duplicated(df_scaled)
df_scaled_unique <- df_scaled[dedup_index, ]
group_var_unique <- group_var[dedup_index]
# UMAP
umap_result <- umap(df_scaled_unique)
# Création du data frame pour ggplot
umap_df <- data.frame(
X = umap_result$layout[, 1],
Y = umap_result$layout[, 2],
Groupe = as.factor(group_var_unique)  # La variable de regroupement
)
# Visualisation colorée par groupe
ggplot(umap_df, aes(x = X, y = Y, color = Groupe)) +
geom_point(alpha = 0.7, size = 3) +
ggtitle("Projection UMAP avec couleur par statut de demande") +
theme_minimal() +
theme(legend.position = "bottom")
library(MASS)
full.model <- glm(benef_trans_eco ~ ., data = df_clean_fonds_vert, family = binomial) # estimation du modèle complet
regression.log <- stepAIC(full.model,direction = "backward",  trace = FALSE) # Backward regression model
stargazer(regression.log,   title="Modèles de regression logistique",align=TRUE, type="text", digits=4)
stargazer(regression.log,   title="Modèles de regression logistique",align=TRUE, type="text", digits=4)
stargazer(regression.log,   title="Modèles de regression logistique",align=TRUE, type="text", digits=4)
df_clean_fonds_vert$benef_trans_eco
class(df_clean_fonds_vert$benef_trans_eco)
df_fonds_vert= read.csv("fonds_vert.csv", sep = ",", dec= ".")
# Typage de la variable taux de creation CHAR---> INT
# Suppression des colonnes qui n'apportent pas d'info
dim(df_fonds_vert)
df_fonds_vert <- df_fonds_vert[, colSums(df_fonds_vert, na.rm = TRUE) > 0]
knitr::opts_chunk$set(echo = TRUE)
import warnings
knitr::opts_chunk$set(echo = TRUE)
warnings.simplefilter("ignore", UserWarning)
